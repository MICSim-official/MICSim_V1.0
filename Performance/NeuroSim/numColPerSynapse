Adder.cpp:		if (param->synchronous) {
Adder.cpp:		if(param->validated){
Adder.cpp:				readDynamicEnergy *= param->delta; 	// switching activity of adder, delta = 0.15 by default
Buffer.cpp:		lengthRow = (double)interface_width * param->widthInFeatureSizeSRAM * tech.featureSize;
Buffer.cpp:		lengthCol = (double)ceil((double)numBit/(double)interface_width) * param->heightInFeatureSizeSRAM * tech.featureSize;
Buffer.cpp:		if (param->synchronous) {
Buffer.cpp:				double resCellAccess = CalculateOnResistance(param->widthAccessCMOS * tech.featureSize, NMOS, inputParameter.temperature, tech);
Buffer.cpp:				double capCellAccess = CalculateDrainCap(param->widthAccessCMOS * tech.featureSize, NMOS, param->widthInFeatureSizeSRAM * tech.featureSize, tech);
Buffer.cpp:				double resPullDown = CalculateOnResistance(param->widthSRAMCellNMOS * tech.featureSize, NMOS, inputParameter.temperature, tech);
Buffer.cpp:				tau *= log(tech.vdd / (tech.vdd - param->minSenseVoltage / 2));   
Buffer.cpp:				double gm = CalculateTransconductance(param->widthAccessCMOS * tech.featureSize, NMOS, tech);
Bus.cpp:	unitLengthWireResistance = param->unitLengthWireResistance;
Bus.cpp:			wireWidth += busWidth*param->wireWidth/foldedratio;
Bus.cpp:		if (param->synchronous) {
Chip.cpp:	numRowPerSynapse = param->numRowPerSynapse;
Chip.cpp:	numColPerSynapse = param->numColPerSynapse;
Chip.cpp:	if (param->novelMapping) {
Chip.cpp:				&&(netStructure[i][2]*netStructure[i][3]*netStructure[i][4]*numRowPerSynapse >= param->numRowSubArray)) {
Chip.cpp:	if (param->pipeline) {
Chip.cpp:		if (maxSpeedUpDegree < param->speedUpDegree) {
Chip.cpp:			param->speedUpDegree = maxSpeedUpDegree;
Chip.cpp:		int boundIFMSize = ceil((double) maxIFMSize/(param->speedUpDegree));
Chip.cpp:	numRowPerSynapse = param->numRowPerSynapse;
Chip.cpp:	numColPerSynapse = param->numColPerSynapse;
Chip.cpp:	if (param->novelMapping) {		// Novel Mapping
Chip.cpp:		if (maxPESizeNM < 2*param->numRowSubArray) {
Chip.cpp:			*desiredPESizeNM = MAX(maxPESizeNM, 2*param->numRowSubArray);
Chip.cpp:			for (double thisPESize = MAX(maxPESizeNM, 2*param->numRowSubArray); thisPESize> 2*param->numRowSubArray; thisPESize/=2) {
Chip.cpp:			*desiredTileSizeCM = MAX(maxTileSizeCM, 4*param->numRowSubArray);
Chip.cpp:			for (double thisTileSize = MAX(maxTileSizeCM, 4*param->numRowSubArray); thisTileSize > 4*param->numRowSubArray; thisTileSize/=2) {
Chip.cpp:			for (double thisPESize = (*desiredTileSizeCM)/2; thisPESize > 2*param->numRowSubArray; thisPESize/=2) {
Chip.cpp:		if (maxTileSizeCM < 4*param->numRowSubArray) {
Chip.cpp:			*desiredTileSizeCM = MAX(maxTileSizeCM, 4*param->numRowSubArray);
Chip.cpp:			for (double thisTileSize = MAX(maxTileSizeCM, 4*param->numRowSubArray); thisTileSize > 4*param->numRowSubArray; thisTileSize/=2) {
Chip.cpp:			for (double thisPESize = (*desiredTileSizeCM)/2; thisPESize > 2*param->numRowSubArray; thisPESize/=2) {
Chip.cpp:	if (param->pipeline) {
Chip.cpp:		if (! param->pipeline) {
Chip.cpp:				globalBusWidth += (desiredTileSizeCM)+(desiredTileSizeCM)/param->numColMuxed;
Chip.cpp:				globalBusWidth += (desiredPESizeNM)*ceil((double)sqrt(numPENM))+(desiredPESizeNM)*ceil((double)sqrt(numPENM))/param->numColMuxed;
Chip.cpp:				globalBusWidth += ((desiredTileSizeCM)+(desiredTileSizeCM)/param->numColMuxed)*numTileEachLayer[0][i]*numTileEachLayer[1][i];
Chip.cpp:				globalBusWidth += ((desiredPESizeNM)*ceil((double)sqrt(numPENM))+(desiredPESizeNM)*ceil((double)sqrt(numPENM))/param->numColMuxed)*numTileEachLayer[0][i]*numTileEachLayer[1][i];
Chip.cpp:	while (globalBusWidth > param->maxGlobalBusWidth) {
Chip.cpp:	int bufferSize = param->numBitInput*maxLayerInput;										 
Chip.cpp:	//globalBuffer->Initialize(param->numBitInput*maxLayerInput, globalBusWidth, 1, param->unitLengthWireResistance, param->clkFreq, param->globalBufferType);
Chip.cpp:	numBufferCore = ceil(bufferSize/(param->globalBufferCoreSizeRow*param->globalBufferCoreSizeCol));
Chip.cpp:	globalBuffer->Initialize((param->globalBufferCoreSizeRow*param->globalBufferCoreSizeCol), param->globalBufferCoreSizeCol, 1, param->unitLengthWireResistance, param->clkFreq, param->globalBufferType);
Chip.cpp:	maxPool->Initialize(param->numBitInput, 2*2, (desiredTileSizeCM), param->clkFreq);
Chip.cpp:	GhTree->Initialize((numTileRow), (numTileCol), param->globalBusDelayTolerance, globalBusWidth, param->clkFreq);
Chip.cpp:	if (param->chipActivation) {
Chip.cpp:		if (param->novelMapping) {
Chip.cpp:			maxAddFromSubArray = (int) max(ceil((double)(desiredPESizeCM)/(double)param->numRowSubArray), ceil((double)(desiredPESizeNM)/(double)param->numRowSubArray));   // from subArray to ProcessingUnit
Chip.cpp:			if (param->pipeline) {
Chip.cpp:			if (param->parallelRead) {
Chip.cpp:				Gaccumulation->Initialize((int) maxTileAdded, ceil((double) log2((double) param->levelOutput))+param->numBitInput+param->numColPerSynapse+1+ceil((double) log2((double) maxAddFromSubArray)), 
Chip.cpp:										ceil((double) maxThroughputTile/(double) param->numColMuxed), param->clkFreq);
Chip.cpp:				Gaccumulation->Initialize((int) maxTileAdded, ceil((double) log2((double) param->numRowSubArray)+(double) param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+ceil((double) log2((double) maxAddFromSubArray)), 
Chip.cpp:										ceil((double) maxThroughputTile/(double) param->numColMuxed), param->clkFreq);
Chip.cpp:			if (param->reLu) {
Chip.cpp:				GreLu->Initialize(ceil((double) maxThroughputTile/(double) param->numColMuxed), param->numBitInput, param->clkFreq);
Chip.cpp:				Gsigmoid->Initialize(false, param->numBitInput, ceil((double) log2((double) param->numRowSubArray)+(double) param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+log2((double) maxAddFromSubArray)+ceil((double) log2((double) maxTileAdded)), 
Chip.cpp:										ceil((double) maxThroughputTile/(double) param->numColMuxed), param->clkFreq);
Chip.cpp:			maxAddFromSubArray = (int) ceil((double)(desiredPESizeCM)/(double)param->numRowSubArray);   // from subArray to ProcessingUnit
Chip.cpp:			if (param->pipeline) {
Chip.cpp:			if (param->parallelRead) {
Chip.cpp:				Gaccumulation->Initialize((int) maxTileAdded, ceil((double)log2((double)param->levelOutput))+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)maxAddFromSubArray)), 
Chip.cpp:										ceil((double)(desiredTileSizeCM)/(double)param->numColMuxed), param->clkFreq);
Chip.cpp:				Gaccumulation->Initialize((int) maxTileAdded, ceil((double)log2((double)param->numRowSubArray)+(double)param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)maxAddFromSubArray)), 
Chip.cpp:										ceil((double)(desiredTileSizeCM)/(double)param->numColMuxed), param->clkFreq);
Chip.cpp:			if (param->reLu) {
Chip.cpp:				GreLu->Initialize(ceil((double)(desiredTileSizeCM)/(double)param->numColMuxed), param->numBitInput, param->clkFreq);
Chip.cpp:				Gsigmoid->Initialize(false, param->numBitInput, ceil((double) log2((double) param->numRowSubArray)+(double) param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+log2((double) maxAddFromSubArray)+ceil((double) log2((double) maxTileAdded)), 
Chip.cpp:										ceil((double) (desiredTileSizeCM)/(double) param->numColMuxed), param->clkFreq);
Chip.cpp:		if (param->novelMapping) {
Chip.cpp:			if (param->pipeline) {
Chip.cpp:			if (param->parallelRead) {
Chip.cpp:				Gaccumulation->Initialize((int) maxTileAdded, param->numBitInput, ceil((double) maxThroughputTile/(double) param->numColMuxed), param->clkFreq);
Chip.cpp:				Gaccumulation->Initialize((int) maxTileAdded, param->numBitInput, ceil((double) maxThroughputTile/(double) param->numColMuxed), param->clkFreq);
Chip.cpp:			if (param->parallelRead) {
Chip.cpp:				Gaccumulation->Initialize((int) maxTileAdded, param->numBitInput, ceil((double) (desiredTileSizeCM)/(double) param->numColMuxed), param->clkFreq);
Chip.cpp:				Gaccumulation->Initialize((int) maxTileAdded, param->numBitInput, ceil((double) (desiredTileSizeCM)/(double) param->numColMuxed), param->clkFreq);
Chip.cpp:	if (param->novelMapping) {
Chip.cpp:	GhTree->CalculateArea(max(NMheight, CMheight), max(NMwidth, CMwidth), param->treeFoldedRatio);
Chip.cpp:	if (param->chipActivation) {
Chip.cpp:		if (param->reLu) {
Chip.cpp:	numRowPerSynapse = param->numRowPerSynapse;
Chip.cpp:	numColPerSynapse = param->numColPerSynapse;
Chip.cpp:	newMemory = LoadInWeightData(newweightfile, numRowPerSynapse, numColPerSynapse, param->maxConductance, param->minConductance);
Chip.cpp:				tileInput = CopyInput(inputVector, i*desiredTileSizeCM, numInVector*param->numBitInput, numRowMatrix);
Chip.cpp:									numRowMatrix, numColMatrix, numInVector*param->numBitInput, cell, &tileReadLatency, &tileReadDynamicEnergy, &tileLeakage,
Chip.cpp:			if (param->chipActivation) {
Chip.cpp:				if (param->reLu) {
Chip.cpp:			double numBitToLoadOut = weightMatrixRow*param->numBitInput*numInVector;
Chip.cpp:			double numBitToLoadIn = ceil(weightMatrixCol/param->numColPerSynapse)*param->numBitInput*numInVector/(netStructure[l][6]? 4:1);
Chip.cpp:				tileInput = ReshapeInput(inputVector, i*desiredPESizeNM, (int) (netStructure[l][0]-netStructure[l][3]+1)*(netStructure[l][1]-netStructure[l][4]+1)*param->numBitInput, 
Chip.cpp:									numRowMatrix, numColMatrix, numInVector*param->numBitInput, cell, 
Chip.cpp:			if (param->chipActivation) {
Chip.cpp:				if (param->reLu) {
Chip.cpp:			double numBitToLoadOut = weightMatrixRow*param->numBitInput*numInVector/netStructure[l][3];
Chip.cpp:			double numBitToLoadIn = ceil(weightMatrixCol/param->numColPerSynapse)*param->numBitInput*numInVector/(netStructure[l][6]? 4:1);
Chip.cpp:				int arrayForOneMatrixRow = ceil((double) netStructure[i][2]*(double) netStructure[i][3]*(double) netStructure[i][4]*(double) numRowPerSynapse/(double) param->numRowSubArray);
Chip.cpp:				int arrayForOneMatrixCol = ceil((double) netStructure[i][5]*(double) numColPerSynapse/(double) param->numColSubArray);
Chip.cpp:				int numSubArrayRow = ceil((double) desiredPESizeCM/(double) param->numRowSubArray);
Chip.cpp:				int numSubArrayCol = ceil((double) desiredPESizeCM/(double) param->numColSubArray);
Chip.cpp:				int arrayForOneMatrixRow = ceil((double) netStructure[i][2]*(double) numRowPerSynapse/(double) param->numRowSubArray);
Chip.cpp:				int arrayForOneMatrixCol = ceil((double) netStructure[i][5]*(double) numColPerSynapse/(double) param->numColSubArray);
Chip.cpp:				int numSubArrayRow = ceil((double) desiredPESizeNM/(double) param->numRowSubArray);
Chip.cpp:				int numSubArrayCol = ceil((double) desiredPESizeNM/(double) param->numColSubArray);
Chip.cpp:			if (!param->pipeline) {
Chip.cpp:			if (!param->pipeline) {
Chip.cpp:		if (!param->pipeline) {
Chip.cpp:	double NormalizedMax = pow(2, param->synapseBit);
Chip.cpp:	double RealMax = param->algoWeightMax;
Chip.cpp:	double RealMin = param->algoWeightMin;
Chip.cpp:				int cellrange = pow(2, param->cellBit);
Chip.cpp:				if (param->BNNparallelMode) {
Chip.cpp:				} else if (param->XNORparallelMode || param->XNORsequentialMode) {
Chip.cpp:		if (param->XNORparallelMode || param->XNORsequentialMode) {
Chip.cpp:				if (param->BNNparallelMode) {
Chip.cpp:				} else if (param->XNORparallelMode || param->XNORsequentialMode) {
Chip.cpp:		if (param->XNORparallelMode || param->XNORsequentialMode) {
Comparator.cpp:		if(param->validated){
Comparator.cpp:			readDynamicEnergy *= param->epsilon; 	// switching activity of control circuits, epsilon = 0.05 by default
CurrentSenseAmp.cpp:	double R_start = (double) 1/param->maxConductance;
CurrentSenseAmp.cpp:	double R_index = (double) 1/param->minConductance - (double) 1/param->maxConductance;
CurrentSenseAmp.cpp:	columnRes *= 0.5/param->readVoltage;
CurrentSenseAmp.cpp:		if (param->deviceroadmap == 1) {  // HP
CurrentSenseAmp.cpp:			if (param->technode == 130) {
CurrentSenseAmp.cpp:			} else if (param->technode == 90) {
CurrentSenseAmp.cpp:			} else if (param->technode == 65) {
CurrentSenseAmp.cpp:			} else if (param->technode == 45 || param->technode == 32) {
CurrentSenseAmp.cpp:	columnRes *= 0.5/param->readVoltage;
CurrentSenseAmp.cpp:		if (param->deviceroadmap == 1) {  // HP
CurrentSenseAmp.cpp:			if (param->technode == 130) {
CurrentSenseAmp.cpp:			} else if (param->technode == 90) {
CurrentSenseAmp.cpp:			} else if (param->technode == 65) {
CurrentSenseAmp.cpp:			} else if (param->technode == 45) {
CurrentSenseAmp.cpp:			} else if (param->technode == 32){  
CurrentSenseAmp.cpp:			} else if (param->technode == 22){   
CurrentSenseAmp.cpp:			} else if (param->technode == 14){  
CurrentSenseAmp.cpp:			} else if (param->technode == 10){  
CurrentSenseAmp.cpp:			if (param->technode == 130) {
CurrentSenseAmp.cpp:			} else if (param->technode == 90) {
CurrentSenseAmp.cpp:			} else if (param->technode == 65) {
CurrentSenseAmp.cpp:			} else if (param->technode == 45) {
CurrentSenseAmp.cpp:			} else if (param->technode == 32){  
CurrentSenseAmp.cpp:			} else if (param->technode == 22){   
CurrentSenseAmp.cpp:			} else if (param->technode == 14){   
CurrentSenseAmp.cpp:			} else if (param->technode == 10){   
DFF.cpp:		if (param->synchronous) {
DFF.cpp:			readDynamicEnergy *= param->gamma; 	// switching activity of DFF in shifter-add and accumulator, gamma = 0.5 by default
HTree.cpp:	unitLengthWireResistance = param->unitLengthWireResistance;
HTree.cpp:		if (param->synchronous) {
HTree.cpp:		wireWidth = 4*param->wireWidth;
HTree.cpp:		wireWidth = 2*param->wireWidth;
HTree.cpp:		wireWidth = 1*param->wireWidth;
HTree.cpp:	Rho *= (1+0.00451*(param->temp-300));
LevelShifter.cpp:		if (param->validated){			
LevelShifter.cpp:			area = hLS * wLS * numOutput*param->alpha;	//consider wire areas, alpha = 1.44 by default
main.cpp:	param->synapseBit = atoi(argv[2]);              // precision of synapse weight
main.cpp:	param->numBitInput = atoi(argv[3]);             // precision of input neural activation
main.cpp:	if (param->cellBit > param->synapseBit) {
main.cpp:		param->cellBit = param->synapseBit;
main.cpp:	param->conventionalParallel = 0;
main.cpp:	param->conventionalSequential = 0;
main.cpp:	param->BNNparallelMode = 0;                // parallel BNN
main.cpp:	param->BNNsequentialMode = 0;              // sequential BNN
main.cpp:	param->XNORsequentialMode = 0;           // Use several multi-bit RRAM as one synapse
main.cpp:	param->XNORparallelMode = 0;         // Use several multi-bit RRAM as one synapse
main.cpp:	switch(param->operationmode) {
main.cpp:		case 6:	    param->XNORparallelMode = 1;               break;     
main.cpp:		case 5:	    param->XNORsequentialMode = 1;             break;     
main.cpp:		case 4:	    param->BNNparallelMode = 1;                break;     
main.cpp:		case 3:	    param->BNNsequentialMode = 1;              break;    
main.cpp:		case 2:	    param->conventionalParallel = 1;           break;     
main.cpp:		case 1:	    param->conventionalSequential = 1;         break;    
main.cpp:	if (param->XNORparallelMode || param->XNORsequentialMode) {
main.cpp:		param->numRowPerSynapse = 2;
main.cpp:		param->numRowPerSynapse = 1;
main.cpp:	if (param->BNNparallelMode) {
main.cpp:		param->numColPerSynapse = 2;
main.cpp:	} else if (param->XNORparallelMode || param->XNORsequentialMode || param->BNNsequentialMode) {
main.cpp:		param->numColPerSynapse = 1;
main.cpp:		param->numColPerSynapse = ceil((double)param->synapseBit/(double)param->cellBit); 
main.cpp:	if (!param->novelMapping) {
main.cpp:	cout << "User-defined SubArray Size: " << param->numRowSubArray << "x" << param->numColSubArray << endl;
main.cpp:	if (param->synchronous){
main.cpp:		if(param->clkFreq > 1/clkPeriod){
main.cpp:			param->clkFreq = 1/clkPeriod;
main.cpp:	if (! param->pipeline) {
main.cpp:			if (param->synchronous) {
main.cpp:			if (param->synchronous) {
main.cpp:	if (! param->pipeline) {
main.cpp:		if (param->synchronous) cout << "Chip clock period is: " << clkPeriod*1e9 << "ns" <<endl;
main.cpp:		if (param->synchronous) cout << "Chip clock period is: " << clkPeriod*1e9 << "ns" <<endl;
main.cpp:	if (! param->pipeline) {
main.cpp:		if(param->validated){
main.cpp:			cout << "Energy Efficiency TOPS/W (Layer-by-Layer Process): " << numComputation/(chipReadDynamicEnergy*1e12+chipLeakageEnergy*1e12)/param->zeta << endl;	// post-layout energy increase, zeta = 1.23 by default
main.cpp:		if(param->validated){
main.cpp:			cout << "Energy Efficiency TOPS/W (Pipelined Process): " << numComputation/(chipReadDynamicEnergy*1e12+chipLeakageEnergy*1e12)/param->zeta << endl;	// post-layout energy increase, zeta = 1.23 by default
MaxPooling.cpp:		if (param->synchronous) { 
MaxPooling.cpp:		if(param->validated){
MaxPooling.cpp:			readDynamicEnergy *= param->epsilon; 	// switching activity of control circuits, epsilon = 0.05 by default
MultilevelSAEncoder.cpp:		if(param->validated){
MultilevelSAEncoder.cpp:			readDynamicEnergy *= param->epsilon; 	// switching activity of control circuits, epsilon = 0.05 by default
MultilevelSenseAmp.cpp:				double R_start = (double) param->resistanceOn / param->numRowSubArray;
MultilevelSenseAmp.cpp:				double R_index = (double) param->resistanceOff / param->numRowSubArray;
MultilevelSenseAmp.cpp:				double R_start = (double) param->resistanceOn;
MultilevelSenseAmp.cpp:				double R_index = (double) param->resistanceOff;
MultilevelSenseAmp.cpp:	columnRes *= 0.5/param->readVoltage;
MultilevelSenseAmp.cpp:		if (param->deviceroadmap == 1) {  // HP
MultilevelSenseAmp.cpp:			if (param->technode == 130) {
MultilevelSenseAmp.cpp:			} else if (param->technode == 90) {
MultilevelSenseAmp.cpp:			} else if (param->technode == 65) {
MultilevelSenseAmp.cpp:			} else if (param->technode == 45 || param->technode == 32) {
MultilevelSenseAmp.cpp:	columnRes *= 0.5/param->readVoltage;
MultilevelSenseAmp.cpp:			if (param->deviceroadmap == 1) {  // HP
MultilevelSenseAmp.cpp:				if (param->technode == 130) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 90) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 65) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 45) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 32){  
MultilevelSenseAmp.cpp:				} else if (param->technode == 22){   
MultilevelSenseAmp.cpp:				} else if (param->technode == 14){  
MultilevelSenseAmp.cpp:				} else if (param->technode == 10){  
MultilevelSenseAmp.cpp:				if (param->technode == 130) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 90) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 65) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 45) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 32){  
MultilevelSenseAmp.cpp:				} else if (param->technode == 22){   
MultilevelSenseAmp.cpp:				} else if (param->technode == 14){   
MultilevelSenseAmp.cpp:				} else if (param->technode == 10){   
MultilevelSenseAmp.cpp:			if (param->deviceroadmap == 1) {  // HP
MultilevelSenseAmp.cpp:				if (param->technode == 130) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 90) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 65) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 45) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 32){  
MultilevelSenseAmp.cpp:				} else if (param->technode == 22){   
MultilevelSenseAmp.cpp:				} else if (param->technode == 14){  
MultilevelSenseAmp.cpp:				} else if (param->technode == 10){  
MultilevelSenseAmp.cpp:				if (param->technode == 130) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 90) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 65) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 45) {
MultilevelSenseAmp.cpp:				} else if (param->technode == 32){  
MultilevelSenseAmp.cpp:				} else if (param->technode == 22){   
MultilevelSenseAmp.cpp:				} else if (param->technode == 14){   
MultilevelSenseAmp.cpp:				} else if (param->technode == 10){   
MultilevelSenseAmp.cpp:	Column_Power *= (1+1.3e-3*(param->temp-300));
ProcessingUnit.cpp:	switch(param->memcelltype) {
ProcessingUnit.cpp:	switch(param->accesstype) {
ProcessingUnit.cpp:	switch(param->transistortype) {
ProcessingUnit.cpp:	switch(param->deviceroadmap) {
ProcessingUnit.cpp:	inputParameter.temperature = param->temp;   // Temperature (K)
ProcessingUnit.cpp:	inputParameter.processNode = param->technode;    // Technology node
ProcessingUnit.cpp:	cell.resistanceOn = param->resistanceOn;	                                // Ron resistance at Vr in the reported measurement data (need to recalculate below if considering the nonlinearity)
ProcessingUnit.cpp:	cell.resistanceOff = param->resistanceOff;	                                // Roff resistance at Vr in the reported measurement dat (need to recalculate below if considering the nonlinearity)
ProcessingUnit.cpp:	cell.readVoltage = param->readVoltage;	                                    // On-chip read voltage for memory cell
ProcessingUnit.cpp:	cell.readPulseWidth = param->readPulseWidth;
ProcessingUnit.cpp:	cell.accessVoltage = param->accessVoltage;                                       // Gate voltage for the transistor in 1T1R
ProcessingUnit.cpp:	cell.resistanceAccess = param->resistanceAccess;
ProcessingUnit.cpp:	cell.featureSize = param->featuresize; 
ProcessingUnit.cpp:	cell.writeVoltage = param->writeVoltage;
ProcessingUnit.cpp:		cell.heightInFeatureSize = param->heightInFeatureSizeSRAM;                   // Cell height in feature size
ProcessingUnit.cpp:		cell.widthInFeatureSize = param->widthInFeatureSizeSRAM;                     // Cell width in feature size
ProcessingUnit.cpp:		cell.widthSRAMCellNMOS = param->widthSRAMCellNMOS;
ProcessingUnit.cpp:		cell.widthSRAMCellPMOS = param->widthSRAMCellPMOS;
ProcessingUnit.cpp:		cell.widthAccessCMOS = param->widthAccessCMOS;
ProcessingUnit.cpp:		cell.minSenseVoltage = param->minSenseVoltage;
ProcessingUnit.cpp:		cell.heightInFeatureSize = (cell.accessType==CMOS_access)? param->heightInFeatureSize1T1R : param->heightInFeatureSizeCrossbar;         // Cell height in feature size
ProcessingUnit.cpp:		cell.widthInFeatureSize = (cell.accessType==CMOS_access)? param->widthInFeatureSize1T1R : param->widthInFeatureSizeCrossbar;            // Cell width in feature size
ProcessingUnit.cpp:	subArray->XNORparallelMode = param->XNORparallelMode;               
ProcessingUnit.cpp:	subArray->XNORsequentialMode = param->XNORsequentialMode;             
ProcessingUnit.cpp:	subArray->BNNparallelMode = param->BNNparallelMode;                
ProcessingUnit.cpp:	subArray->BNNsequentialMode = param->BNNsequentialMode;              
ProcessingUnit.cpp:	subArray->conventionalParallel = param->conventionalParallel;                  
ProcessingUnit.cpp:	subArray->conventionalSequential = param->conventionalSequential;                 
ProcessingUnit.cpp:	subArray->numRow = param->numRowSubArray;
ProcessingUnit.cpp:	subArray->numCol = param->numRowSubArray;
ProcessingUnit.cpp:	subArray->levelOutput = param->levelOutput;
ProcessingUnit.cpp:	subArray->numColMuxed = param->numColMuxed;               // How many columns share 1 read circuit (for neuro mode with analog RRAM) or 1 S/A (for memory mode or neuro mode with digital RRAM)
ProcessingUnit.cpp:    subArray->clkFreq = param->clkFreq;                       // Clock frequency
ProcessingUnit.cpp:	subArray->relaxArrayCellHeight = param->relaxArrayCellHeight;
ProcessingUnit.cpp:	subArray->relaxArrayCellWidth = param->relaxArrayCellWidth;
ProcessingUnit.cpp:	subArray->numReadPulse = param->numBitInput;
ProcessingUnit.cpp:	subArray->avgWeightBit = param->cellBit;
ProcessingUnit.cpp:	subArray->numCellPerSynapse = param->numColPerSynapse;
ProcessingUnit.cpp:	subArray->SARADC = param->SARADC;
ProcessingUnit.cpp:	subArray->currentMode = param->currentMode;
ProcessingUnit.cpp:	subArray->validated = param->validated;
ProcessingUnit.cpp:	int numRow = param->numRowSubArray;
ProcessingUnit.cpp:	int numCol = param->numColSubArray;
ProcessingUnit.cpp:	subArray->Initialize(numRow, numCol, param->unitLengthWireResistance);        // initialize subArray
ProcessingUnit.cpp:	if (param->novelMapping) {
ProcessingUnit.cpp:		if (param->parallelRead) {
ProcessingUnit.cpp:			adderTreeNM->Initialize(numSubArrayRowNM, log2((double)param->levelOutput)+param->numBitInput+param->numColPerSynapse+1, ceil((double)numSubArrayColNM*(double)numCol/(double)param->numColMuxed), param->clkFreq);
ProcessingUnit.cpp:			adderTreeNM->Initialize(numSubArrayRowNM, (log2((double)numRow)+param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1, ceil((double)numSubArrayColNM*(double)numCol/(double)param->numColMuxed), param->clkFreq);
ProcessingUnit.cpp:		bufferInputNM->Initialize(param->numBitInput*numRow, param->clkFreq);
ProcessingUnit.cpp:		if (param->parallelRead) {
ProcessingUnit.cpp:			bufferOutputNM->Initialize((numCol/param->numColMuxed)*(log2((double)param->levelOutput)+param->numBitInput+param->numColPerSynapse+adderTreeNM->numStage), param->clkFreq);
ProcessingUnit.cpp:			bufferOutputNM->Initialize((numCol/param->numColMuxed)*((log2((double)numRow)+param->cellBit-1)+param->numBitInput+param->numColPerSynapse+adderTreeNM->numStage), param->clkFreq);
ProcessingUnit.cpp:		busInputNM->Initialize(HORIZONTAL, numSubArrayRowNM, numSubArrayColNM, 0, numRow, subArray->height, subArray->width, param->clkFreq);
ProcessingUnit.cpp:		busOutputNM->Initialize(VERTICAL, numSubArrayRowNM, numSubArrayColNM, 0, numCol, subArray->height, subArray->width, param->clkFreq);
ProcessingUnit.cpp:	if (param->parallelRead) {
ProcessingUnit.cpp:		adderTreeCM->Initialize(numSubArrayRowCM, log2((double)param->levelOutput)+param->numBitInput+param->numColPerSynapse+1, ceil((double)numSubArrayColCM*(double)numCol/(double)param->numColMuxed), param->clkFreq);
ProcessingUnit.cpp:		adderTreeCM->Initialize(numSubArrayRowCM, (log2((double)numRow)+param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1, ceil((double)numSubArrayColCM*(double)numCol/(double)param->numColMuxed), param->clkFreq);
ProcessingUnit.cpp:	bufferInputCM->Initialize(param->numBitInput*numRow, param->clkFreq);
ProcessingUnit.cpp:	if (param->parallelRead) {
ProcessingUnit.cpp:		bufferOutputCM->Initialize((numCol/param->numColMuxed)*(log2((double)param->levelOutput)+param->numBitInput+param->numColPerSynapse+adderTreeCM->numStage), param->clkFreq);
ProcessingUnit.cpp:		bufferOutputCM->Initialize((numCol/param->numColMuxed)*((log2((double)numRow)+param->cellBit-1)+param->numBitInput+param->numColPerSynapse+adderTreeCM->numStage), param->clkFreq);
ProcessingUnit.cpp:	busInputCM->Initialize(HORIZONTAL, numSubArrayRowCM, numSubArrayColCM, 0, numRow, subArray->height, subArray->width, param->clkFreq);
ProcessingUnit.cpp:	busOutputCM->Initialize(VERTICAL, numSubArrayRowCM, numSubArrayColCM, 0, numCol, subArray->height, subArray->width, param->clkFreq);	
ProcessingUnit.cpp:			for (int i=0; i<ceil((double) weightMatrixRow/(double) param->numRowSubArray); i++) {
ProcessingUnit.cpp:				for (int j=0; j<ceil((double) weightMatrixCol/(double) param->numColSubArray); j++) {
ProcessingUnit.cpp:					int numRowMatrix = min(param->numRowSubArray, weightMatrixRow-i*param->numRowSubArray);
ProcessingUnit.cpp:					int numColMatrix = min(param->numColSubArray, weightMatrixCol-j*param->numColSubArray);
ProcessingUnit.cpp:					if ((i*param->numRowSubArray < weightMatrixRow) && (j*param->numColSubArray < weightMatrixCol) && (i*param->numRowSubArray < weightMatrixRow) ) {
ProcessingUnit.cpp:						subArrayMemory = CopySubArray(newMemory, i*param->numRowSubArray, j*param->numColSubArray, numRowMatrix, numColMatrix);
ProcessingUnit.cpp:						subArrayInput = CopySubInput(inputVector, i*param->numRowSubArray, numInVector, numRowMatrix);
ProcessingUnit.cpp:							int cellRange = pow(2, param->cellBit);
ProcessingUnit.cpp:							if (param->parallelRead) {
ProcessingUnit.cpp:								subArray->levelOutput = param->levelOutput;               // # of levels of the multilevelSenseAmp output
ProcessingUnit.cpp:							columnResistance = GetColumnResistance(input, subArrayMemory, cell, param->parallelRead, subArray->resCellAccess);
ProcessingUnit.cpp:							adderTreeNM->CalculateLatency((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse), ceil((double) weightMatrixRow/(double) param->numRowSubArray), 0);
ProcessingUnit.cpp:							adderTreeNM->CalculatePower((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse), ceil((double) weightMatrixRow/(double) param->numRowSubArray));
ProcessingUnit.cpp:							adderTreeCM->CalculateLatency((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse), ceil((double) weightMatrixRow/(double) param->numRowSubArray), 0);
ProcessingUnit.cpp:							adderTreeCM->CalculatePower((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse), ceil((double) weightMatrixRow/(double) param->numRowSubArray));
ProcessingUnit.cpp:				int cellRange = pow(2, param->cellBit);
ProcessingUnit.cpp:				if (param->parallelRead) {
ProcessingUnit.cpp:					subArray->levelOutput = param->levelOutput;               // # of levels of the multilevelSenseAmp output
ProcessingUnit.cpp:				columnResistance = GetColumnResistance(input, subArrayMemory, cell, param->parallelRead, subArray->resCellAccess);
ProcessingUnit.cpp:		for (int i=0; i<numSubArrayRow/*ceil((double) weightMatrixRow/(double) param->numRowSubArray)*/; i++) {
ProcessingUnit.cpp:			for (int j=0; j<numSubArrayCol/*ceil((double) weightMatrixCol/(double) param->numColSubArray)*/; j++) {
ProcessingUnit.cpp:				if ((i*param->numRowSubArray < weightMatrixRow) && (j*param->numColSubArray < weightMatrixCol) && (i*param->numRowSubArray < weightMatrixRow) ) {
ProcessingUnit.cpp:					int numRowMatrix = min(param->numRowSubArray, weightMatrixRow-i*param->numRowSubArray);
ProcessingUnit.cpp:					int numColMatrix = min(param->numColSubArray, weightMatrixCol-j*param->numColSubArray);
ProcessingUnit.cpp:					subArrayMemory = CopySubArray(newMemory, i*param->numRowSubArray, j*param->numColSubArray, numRowMatrix, numColMatrix);
ProcessingUnit.cpp:					subArrayInput = CopySubInput(inputVector, i*param->numRowSubArray, numInVector, numRowMatrix);
ProcessingUnit.cpp:						int cellRange = pow(2, param->cellBit);
ProcessingUnit.cpp:						if (param->parallelRead) {
ProcessingUnit.cpp:							subArray->levelOutput = param->levelOutput;               // # of levels of the multilevelSenseAmp output
ProcessingUnit.cpp:						columnResistance = GetColumnResistance(input, subArrayMemory, cell, param->parallelRead, subArray->resCellAccess);
ProcessingUnit.cpp:			adderTreeNM->CalculateLatency((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse), ceil((double) weightMatrixRow/(double) param->numRowSubArray), 0);
ProcessingUnit.cpp:			adderTreeNM->CalculatePower((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse), ceil((double) weightMatrixRow/(double) param->numRowSubArray));
ProcessingUnit.cpp:			adderTreeCM->CalculateLatency((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse), ceil((double) weightMatrixRow/(double) param->numRowSubArray), 0);
ProcessingUnit.cpp:			adderTreeCM->CalculatePower((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse), ceil((double) weightMatrixRow/(double) param->numRowSubArray));
ProcessingUnit.cpp:		// output buffer: total num of data transferred = weightMatrixRow*numInVector/param->numBitInput (total num of IFM in the PE) *adderTree->numAdderTree*adderTree->numAdderBit (bit precision of OFMs) 
ProcessingUnit.cpp:			bufferInputNM->CalculateLatency(0, weightMatrixRow/param->numRowPerSynapse*numInVector/(bufferInputNM->numDff));
ProcessingUnit.cpp:			bufferOutputNM->CalculateLatency(0, weightMatrixCol/param->numColPerSynapse*adderTreeNM->numAdderBit*numInVector/param->numBitInput/(bufferOutputNM->numDff));
ProcessingUnit.cpp:			bufferInputNM->CalculatePower(weightMatrixRow/param->numRowPerSynapse*numInVector/(bufferInputNM->numDff), bufferInputNM->numDff, false);
ProcessingUnit.cpp:			bufferOutputNM->CalculatePower(weightMatrixCol/param->numColPerSynapse*adderTreeNM->numAdderBit*numInVector/param->numBitInput/(bufferOutputNM->numDff), bufferOutputNM->numDff, false);
ProcessingUnit.cpp:			busInputNM->CalculateLatency(weightMatrixRow/param->numRowPerSynapse*numInVector/(busInputNM->busWidth)); 
ProcessingUnit.cpp:			busInputNM->CalculatePower(busInputNM->busWidth, weightMatrixRow/param->numRowPerSynapse*numInVector/(busInputNM->busWidth));
ProcessingUnit.cpp:			if (param->parallelRead) {
ProcessingUnit.cpp:				busOutputNM->CalculateLatency((weightMatrixCol/param->numColPerSynapse*log2((double)param->levelOutput)*numInVector/param->numBitInput)/(busOutputNM->numRow*busOutputNM->busWidth));
ProcessingUnit.cpp:				busOutputNM->CalculatePower(busOutputNM->numRow*busOutputNM->busWidth, (weightMatrixCol/param->numColPerSynapse*log2((double)param->levelOutput)*numInVector/param->numBitInput)/(busOutputNM->numRow*busOutputNM->busWidth));
ProcessingUnit.cpp:				busOutputNM->CalculateLatency((weightMatrixCol/param->numColPerSynapse*(log2((double)param->numRowSubArray)+param->cellBit-1)*numInVector/param->numBitInput)/(busOutputNM->numRow*busOutputNM->busWidth));
ProcessingUnit.cpp:				busOutputNM->CalculatePower(busOutputNM->numRow*busOutputNM->busWidth, (weightMatrixCol/param->numColPerSynapse*(log2((double)param->numRowSubArray)+param->cellBit-1)*numInVector/param->numBitInput)/(busOutputNM->numRow*busOutputNM->busWidth));
ProcessingUnit.cpp:			if (!param->synchronous) {
ProcessingUnit.cpp:			bufferInputCM->CalculateLatency(0, weightMatrixRow/param->numRowPerSynapse*numInVector/(bufferInputCM->numDff));
ProcessingUnit.cpp:			bufferOutputCM->CalculateLatency(0, weightMatrixCol/param->numColPerSynapse*adderTreeCM->numAdderBit*numInVector/param->numBitInput/(bufferOutputCM->numDff));
ProcessingUnit.cpp:			bufferInputCM->CalculatePower(weightMatrixRow/param->numRowPerSynapse*numInVector/(bufferInputCM->numDff), bufferInputCM->numDff, false);
ProcessingUnit.cpp:			bufferOutputCM->CalculatePower(weightMatrixCol/param->numColPerSynapse*adderTreeCM->numAdderBit*numInVector/param->numBitInput/(bufferOutputCM->numDff), bufferOutputCM->numDff, false);
ProcessingUnit.cpp:			busInputCM->CalculateLatency(weightMatrixRow/param->numRowPerSynapse*numInVector/(busInputCM->busWidth)); 
ProcessingUnit.cpp:			busInputCM->CalculatePower(busInputCM->busWidth, weightMatrixRow/param->numRowPerSynapse*numInVector/(busInputCM->busWidth));
ProcessingUnit.cpp:			if (param->parallelRead) {
ProcessingUnit.cpp:				busOutputCM->CalculateLatency((weightMatrixCol/param->numColPerSynapse*log2((double)param->levelOutput)*numInVector/param->numBitInput)/(busOutputCM->numRow*busOutputCM->busWidth));
ProcessingUnit.cpp:				busOutputCM->CalculatePower(busOutputCM->numRow*busOutputCM->busWidth, (weightMatrixCol/param->numColPerSynapse*log2((double)param->levelOutput)*numInVector/param->numBitInput)/(busOutputCM->numRow*busOutputCM->busWidth));
ProcessingUnit.cpp:				busOutputCM->CalculateLatency((weightMatrixCol/param->numColPerSynapse*(log2((double)param->numRowSubArray)+param->cellBit-1)*numInVector/param->numBitInput)/(busOutputCM->numRow*busOutputCM->busWidth));
ProcessingUnit.cpp:				busOutputCM->CalculatePower(busOutputCM->numRow*busOutputCM->busWidth, (weightMatrixCol/param->numColPerSynapse*(log2((double)param->numRowSubArray)+param->cellBit-1)*numInVector/param->numBitInput)/(busOutputCM->numRow*busOutputCM->busWidth));
ProcessingUnit.cpp:			if (!param->synchronous) {
ProcessingUnit.cpp:					totalWireResistance = (double) 1.0/weight[i][j] + (j + 1) * param->wireResistanceRow + (weight.size() - i) * param->wireResistanceCol + cell.resistanceAccess;
ProcessingUnit.cpp:					totalWireResistance = (double) 1.0/weight[i][j] + (j + 1) * param->wireResistanceRow + (weight.size() - i) * param->wireResistanceCol;
ProcessingUnit.cpp:				totalWireResistance = (double) 1.0/weight[i][j] + (j + 1) * param->wireResistanceRow + (weight.size() - i) * param->wireResistanceCol;
ProcessingUnit.cpp:				double totalWireResistance = (double) (resCellAccess + param->wireResistanceCol);
RowDecoder.cpp:		if(param->validated){
RowDecoder.cpp:			readDynamicEnergy *= param->epsilon; 	// switching activity of control circuits, epsilon = 0.05 by default
SarADC.cpp:	columnRes *= 0.5/param->readVoltage;
SarADC.cpp:		if (param->deviceroadmap == 1) {  // HP
SarADC.cpp:			if (param->technode == 130) {
SarADC.cpp:			} else if (param->technode == 90) {
SarADC.cpp:			} else if (param->technode == 65) {
SarADC.cpp:			} else if (param->technode == 45) {
SarADC.cpp:			} else if (param->technode == 32){  
SarADC.cpp:			} else if (param->technode == 22){   
SarADC.cpp:			} else if (param->technode == 14){   
SarADC.cpp:			} else if (param->technode == 10){   
SarADC.cpp:			if (param->technode == 130) {
SarADC.cpp:			} else if (param->technode == 90) {
SarADC.cpp:			} else if (param->technode == 65) {
SarADC.cpp:			} else if (param->technode == 45) {
SarADC.cpp:			} else if (param->technode == 32){  
SarADC.cpp:			} else if (param->technode == 22){   
SarADC.cpp:			} else if (param->technode == 14){   
SarADC.cpp:			} else if (param->technode == 10){   
SarADC.cpp:	Column_Power *= (1+1.3e-3*(param->temp-300));
ShiftAdd.cpp:			if (param->synchronous) {
ShiftAdd.cpp:			if (param->synchronous) {
ShiftAdd.cpp:			dff.CalculatePower(numRead, numDff, param->validated);
ShiftAdd.cpp:			dff.CalculatePower(numRead, numDff, param->validated);
Sigmoid.cpp:		if (param->synchronous) {
SubArray.cpp:				if (CalculateclkFreq || !param->synchronous) {
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray.cpp:					if (param->synchronous) {
SubArray.cpp:						readLatencyADC = (precharger.readLatency + colDelay + senseAmp.readLatency) * numReadOperationPerRow*numRow*activityRowRead * (validated==true? param->beta : 1);;
SubArray.cpp:						readLatencyOther = wlDecoder.readLatency * numRow*activityRowRead * (validated==true? param->beta : 1);;
SubArray.cpp:				if (CalculateclkFreq || !param->synchronous) {
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray.cpp:					if (param->synchronous) {
SubArray.cpp:						readLatencyADC = (precharger.readLatency + colDelay + multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:						readLatencyOther = MAX(wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0) ) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:				if (CalculateclkFreq || !param->synchronous) {
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray.cpp:					if (param->synchronous) {
SubArray.cpp:						readLatencyADC = (precharger.readLatency + colDelay + senseAmp.readLatency) * numReadOperationPerRow*numRow*activityRowRead * (validated==true? param->beta : 1);;
SubArray.cpp:						readLatencyOther = wlDecoder.readLatency * numRow*activityRowRead * (validated==true? param->beta : 1);;
SubArray.cpp:				if (CalculateclkFreq || !param->synchronous) {
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray.cpp:					if (param->synchronous) {
SubArray.cpp:						readLatencyADC = (precharger.readLatency + colDelay + multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency) * numColMuxed * (validated==true? param->beta : 1);;
SubArray.cpp:						readLatencyOther = MAX(wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0) ) * numColMuxed * (validated==true? param->beta : 1);;
SubArray.cpp:				if (CalculateclkFreq || !param->synchronous) {		
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);		// latency factor of sensing cycle, beta = 1.4 by default
SubArray.cpp:					if (param->synchronous) {
SubArray.cpp:						readLatencyADC = (multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency + colDelay) * (numRow*activityRowRead*numColMuxed) * (validated==true? param->beta : 1);
SubArray.cpp:						readLatencyOther = MAX((wlDecoder.readLatency + wlNewDecoderDriver.readLatency + wlDecoderDriver.readLatency)*numRow*activityRowRead, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:					// writeLatencyArray = numWritePulse * param->writePulseWidthLTP + (-numErasePulse) * param->writePulseWidthLTD;
SubArray.cpp:				if (CalculateclkFreq || !param->synchronous) {				
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default									
SubArray.cpp:					if (param->synchronous) {
SubArray.cpp:						readLatencyADC = (multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency + colDelay) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:						readLatencyOther = MAX(wlNewSwitchMatrix.readLatency + wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:				if (CalculateclkFreq || !param->synchronous) {
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray.cpp:					if (param->synchronous) {
SubArray.cpp:						readLatencyADC = (rowCurrentSenseAmp.readLatency + colDelay) * numRow*activityRowRead*numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:						readLatencyOther = MAX((wlDecoder.readLatency + wlNewDecoderDriver.readLatency + wlDecoderDriver.readLatency)*numRow*activityRowRead, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:				if (CalculateclkFreq || !param->synchronous) {
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray.cpp:					if (param->synchronous) {
SubArray.cpp:						readLatencyADC = (multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency + colDelay) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:						readLatencyOther = MAX(wlNewSwitchMatrix.readLatency + wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:				dff.CalculatePower(numReadOperationPerRow*numRow*activityRowRead, numReadCellPerOperationNeuro/numCellPerSynapse*(adder.numBit+1), param->validated);
SubArray.cpp:				dff.CalculatePower(numReadOperationPerRow*numRow*activityRowRead, numReadCellPerOperationNeuro/numCellPerSynapse*(adder.numBit+1), param->validated);
SubArray.cpp:				dff.CalculatePower(numColMuxed*numRow*activityRowRead, numReadCells*(adder.numBit+1), param->validated); 
SubArray.cpp:				dff.CalculatePower(numColMuxed*numRow*activityRowRead, numReadCells*(adder.numBit+1), param->validated); 
Tile.cpp:	if (!param->chipActivation) {
Tile.cpp:		if (param->reLu) {
Tile.cpp:	numRowPerSynapse = param->numRowPerSynapse;
Tile.cpp:	numColPerSynapse = param->numColPerSynapse;
Tile.cpp:	numSubArrayNM = ceil((double)peSizeNM/(double)param->numRowSubArray)*ceil((double)peSizeNM/(double)param->numColSubArray);
Tile.cpp:	numSubArrayCM = ceil((double)peSizeCM/(double)param->numRowSubArray)*ceil((double)peSizeCM/(double)param->numColSubArray);
Tile.cpp:	if (param->novelMapping) {
Tile.cpp:		if (param->parallelRead) {
Tile.cpp:			accumulationNM->Initialize(numPENM, ceil((double)log2((double)param->levelOutput))+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeNM/(double)param->numRowSubArray)), 
Tile.cpp:									ceil((double)numPENM*(double)param->numColSubArray/(double)param->numColMuxed), param->clkFreq);
Tile.cpp:			if (!param->chipActivation) {
Tile.cpp:				if (param->reLu) {
Tile.cpp:					reLuNM->Initialize(ceil((double)peSizeNM*(double)param->numColSubArray/(double)param->numColMuxed), param->numBitInput, param->clkFreq);
Tile.cpp:					sigmoidNM->Initialize(false, param->numBitInput, ceil((double)log2((double)param->levelOutput))+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeNM/(double)param->numRowSubArray))+ceil((double)log2((double)numPENM)), 
Tile.cpp:									ceil((double)numPENM*(double)param->numColSubArray/(double)param->numColMuxed), param->clkFreq);
Tile.cpp:				numOutBufferCore = ceil((param->numBitInput*numPENM*param->numColSubArray/param->numColMuxed)/(param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol));
Tile.cpp:				if ((param->numBitInput*numPENM*param->numColSubArray/param->numColMuxed) < (param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol)) {
Tile.cpp:					outputBufferNM->Initialize(param->numBitInput*numPENM*param->numColSubArray/param->numColMuxed, param->numBitInput*numPENM, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:					outputBufferNM->Initialize((param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol), param->tileBufferCoreSizeCol, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:				numOutBufferCore = ceil(((ceil((double)log2((double)param->levelOutput))+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeNM/(double)param->numRowSubArray)))*numPENM*param->numColSubArray/param->numColMuxed)/(param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol));
Tile.cpp:				if (((ceil((double)log2((double)param->levelOutput))+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeNM/(double)param->numRowSubArray)))*numPENM*param->numColSubArray/param->numColMuxed) < (param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol)) {
Tile.cpp:					outputBufferNM->Initialize((ceil((double)log2((double)param->levelOutput))+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeNM/(double)param->numRowSubArray)))*numPENM*param->numColSubArray/param->numColMuxed, 
Tile.cpp:									(ceil((double)log2((double)param->levelOutput))+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeNM/(double)param->numRowSubArray)))*numPENM, 
Tile.cpp:									1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:					outputBufferNM->Initialize((param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol), param->tileBufferCoreSizeCol, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:			accumulationNM->Initialize(numPENM, ceil((double)log2((double)param->numRowSubArray)+(double)param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeNM/(double)param->numRowSubArray)), 
Tile.cpp:									ceil(numPENM*(double)param->numColSubArray/(double)param->numColMuxed), param->clkFreq);
Tile.cpp:			if (!param->chipActivation) {
Tile.cpp:				if (param->reLu) {
Tile.cpp:					reLuNM->Initialize(ceil((double)peSizeNM*(double)param->numColSubArray/(double)param->numColMuxed), param->numBitInput, param->clkFreq);
Tile.cpp:					sigmoidNM->Initialize(false, param->numBitInput, ceil((double)log2((double)param->numRowSubArray)+(double)param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeNM/(double)param->numRowSubArray))+ceil((double)log2((double)numPENM)), 
Tile.cpp:									ceil(numPENM*(double)param->numColSubArray/(double)param->numColMuxed), param->clkFreq);
Tile.cpp:				numOutBufferCore = ceil((param->numBitInput*numPENM*param->numColSubArray/param->numColMuxed)/(param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol));
Tile.cpp:				if ((param->numBitInput*numPENM*param->numColSubArray/param->numColMuxed) < (param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol)) {
Tile.cpp:					outputBufferNM->Initialize(param->numBitInput*numPENM*param->numColSubArray/param->numColMuxed, param->numBitInput*numPENM, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:					outputBufferNM->Initialize((param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol), param->tileBufferCoreSizeCol, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:				numOutBufferCore = ceil(((ceil((double)log2((double)param->numRowSubArray)+(double)param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeNM/(double)param->numRowSubArray)))*numPENM*param->numColSubArray/param->numColMuxed)/(param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol));
Tile.cpp:				if (((ceil((double)log2((double)param->numRowSubArray)+(double)param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeNM/(double)param->numRowSubArray)))*numPENM*param->numColSubArray/param->numColMuxed) < (param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol)) {
Tile.cpp:					outputBufferNM->Initialize((ceil((double)log2((double)param->numRowSubArray)+(double)param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeNM/(double)param->numRowSubArray)))*numPENM*param->numColSubArray/param->numColMuxed, 
Tile.cpp:									(ceil((double)log2((double)param->numRowSubArray)+(double)param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeNM/(double)param->numRowSubArray)))*numPENM, 
Tile.cpp:									1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:					outputBufferNM->Initialize((param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol), param->tileBufferCoreSizeCol, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:		numInBufferCore = ceil((numPENM*param->numBitInput*param->numRowSubArray)/(param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol));
Tile.cpp:		if ((numPENM*param->numBitInput*param->numRowSubArray) < (param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol)) {
Tile.cpp:			inputBufferNM->Initialize(numPENM*param->numBitInput*param->numRowSubArray, numPENM*param->numRowSubArray, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:			inputBufferNM->Initialize((param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol), param->tileBufferCoreSizeCol, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:		hTreeNM->Initialize(numPENM, numPENM, param->localBusDelayTolerance, numPENM*param->numRowSubArray, param->clkFreq);
Tile.cpp:	if (param->parallelRead) {
Tile.cpp:		accumulationCM->Initialize(numPECM, ceil((double)log2((double)param->levelOutput))+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeCM/(double)param->numRowSubArray)), 
Tile.cpp:								ceil((double)numPECM*(double)param->numColSubArray/(double)param->numColMuxed), param->clkFreq);
Tile.cpp:		if (!param->chipActivation) {
Tile.cpp:			if (param->reLu) {
Tile.cpp:				reLuCM->Initialize(ceil((double)peSizeCM*(double)param->numColSubArray/(double)param->numColMuxed), param->numBitInput, param->clkFreq);
Tile.cpp:				sigmoidCM->Initialize(false, param->numBitInput, ceil((double)log2((double)param->levelOutput))+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeCM/(double)param->numRowSubArray))+ceil((double)log2((double)numPECM)), 
Tile.cpp:								ceil((double)numPECM*(double)param->numColSubArray/(double)param->numColMuxed), param->clkFreq);
Tile.cpp:			numOutBufferCore = ceil((param->numBitInput*numPECM*param->numColSubArray/param->numColMuxed)/(param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol));
Tile.cpp:			if ((param->numBitInput*numPECM*param->numColSubArray/param->numColMuxed) < (param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol)) {
Tile.cpp:				outputBufferCM->Initialize(param->numBitInput*numPECM*param->numColSubArray/param->numColMuxed, param->numBitInput*numPECM, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:				outputBufferCM->Initialize((param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol), param->tileBufferCoreSizeCol, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:			numOutBufferCore = ceil(((ceil((double)log2((double)param->levelOutput))+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeCM/(double)param->numRowSubArray)))*numPECM*param->numColSubArray/param->numColMuxed)/(param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol));
Tile.cpp:			if (((ceil((double)log2((double)param->levelOutput))+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeCM/(double)param->numRowSubArray)))*numPECM*param->numColSubArray/param->numColMuxed) < (param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol)) {
Tile.cpp:				outputBufferCM->Initialize((ceil((double)log2((double)param->levelOutput))+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeCM/(double)param->numRowSubArray)))*numPECM*param->numColSubArray/param->numColMuxed, 
Tile.cpp:								(ceil((double)log2((double)param->levelOutput))+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeCM/(double)param->numRowSubArray)))*numPECM, 
Tile.cpp:								1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:				outputBufferCM->Initialize((param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol), param->tileBufferCoreSizeCol, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:		accumulationCM->Initialize(numPECM, ceil((double)log2((double)param->numRowSubArray)+(double)param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeCM/(double)param->numRowSubArray)), 
Tile.cpp:								ceil(numPECM*(double)param->numColSubArray/(double)param->numColMuxed), param->clkFreq);
Tile.cpp:		if (!param->chipActivation) {
Tile.cpp:			if (param->reLu) {
Tile.cpp:				reLuCM->Initialize(ceil((double)peSizeCM*(double)param->numColSubArray/(double)param->numColMuxed), param->numBitInput, param->clkFreq);
Tile.cpp:				sigmoidCM->Initialize(false, param->numBitInput, ceil((double)log2((double)param->numRowSubArray)+(double)param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeCM/(double)param->numRowSubArray))+ceil((double)log2((double)numPECM)), 
Tile.cpp:								ceil(numPECM*(double)param->numColSubArray/(double)param->numColMuxed), param->clkFreq);
Tile.cpp:			numOutBufferCore = ceil((param->numBitInput*numPECM*param->numColSubArray/param->numColMuxed)/(param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol));
Tile.cpp:			if ((param->numBitInput*numPECM*param->numColSubArray/param->numColMuxed) < (param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol)) {
Tile.cpp:				outputBufferCM->Initialize(param->numBitInput*numPECM*param->numColSubArray/param->numColMuxed, param->numBitInput*numPECM, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:				outputBufferCM->Initialize((param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol), param->tileBufferCoreSizeCol, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:			numOutBufferCore = ceil(((ceil((double)log2((double)param->numRowSubArray)+(double)param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeCM/(double)param->numRowSubArray)))*numPECM*param->numColSubArray/param->numColMuxed)/(param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol));
Tile.cpp:			if (((ceil((double)log2((double)param->numRowSubArray)+(double)param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeCM/(double)param->numRowSubArray)))*numPECM*param->numColSubArray/param->numColMuxed) < (param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol)) {
Tile.cpp:				outputBufferCM->Initialize((ceil((double)log2((double)param->numRowSubArray)+(double)param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeCM/(double)param->numRowSubArray)))*numPECM*param->numColSubArray/param->numColMuxed, 
Tile.cpp:								(ceil((double)log2((double)param->numRowSubArray)+(double)param->cellBit-1)+param->numBitInput+param->numColPerSynapse+1+ceil((double)log2((double)peSizeCM/(double)param->numRowSubArray)))*numPECM, 
Tile.cpp:								1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:				outputBufferCM->Initialize((param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol), param->tileBufferCoreSizeCol, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:	numInBufferCore = ceil((numPECM*param->numBitInput*param->numRowSubArray)/(param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol));
Tile.cpp:	if ((numPECM*param->numBitInput*param->numRowSubArray) < (param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol)) {
Tile.cpp:		inputBufferCM->Initialize(numPECM*param->numBitInput*param->numRowSubArray, numPECM*param->numRowSubArray, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:		inputBufferCM->Initialize((param->tileBufferCoreSizeRow*param->tileBufferCoreSizeCol), param->tileBufferCoreSizeCol, 1, param->unitLengthWireResistance, param->clkFreq, param->peBufferType);
Tile.cpp:	hTreeCM->Initialize(numPECM, numPECM, param->localBusDelayTolerance, numPECM*param->numRowSubArray, param->clkFreq);
Tile.cpp:		int numSubArray = ceil((double) peSize/(double) param->numRowSubArray)*ceil((double) peSize/(double) param->numColSubArray);
Tile.cpp:		if (!param->chipActivation) {
Tile.cpp:			if (param->reLu) {
Tile.cpp:		int numSubArray = ceil((double) peSize/(double) param->numRowSubArray)*ceil((double) peSize/(double) param->numColSubArray);
Tile.cpp:		if (!param->chipActivation) {
Tile.cpp:			if (param->reLu) {
Tile.cpp:	numRowPerSynapse = param->numRowPerSynapse;
Tile.cpp:	numColPerSynapse = param->numColPerSynapse;
Tile.cpp:	int numSubArrayRow = ceil((double)peSize/(double)param->numRowSubArray);
Tile.cpp:	int numSubArrayCol = ceil((double)peSize/(double)param->numColSubArray);
Tile.cpp:					accumulationCM->CalculateLatency((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse), ceil((double)weightMatrixRow/(double)peSize), 0);
Tile.cpp:					accumulationCM->CalculatePower((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse), ceil((double)weightMatrixRow/(double)peSize));
Tile.cpp:			accumulationCM->CalculateLatency((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse), numPE, 0);
Tile.cpp:			accumulationCM->CalculatePower((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse), numPE);
Tile.cpp:			if (!param->chipActivation) {
Tile.cpp:				if (param->reLu) {
Tile.cpp:					reLuCM->CalculateLatency((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse)/reLuCM->numUnit);
Tile.cpp:					reLuCM->CalculatePower((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse)/reLuCM->numUnit);
Tile.cpp:					numBitToLoadIn = MAX(ceil(weightMatrixCol/param->numColPerSynapse)*(1+reLuCM->numBit)*numInVector/param->numBitInput, 0);
Tile.cpp:					sigmoidCM->CalculateLatency((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse)/sigmoidCM->numEntry);
Tile.cpp:					sigmoidCM->CalculatePower((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse)/sigmoidCM->numEntry);
Tile.cpp:					numBitToLoadIn = MAX(ceil(weightMatrixCol/param->numColPerSynapse)*(1+sigmoidCM->numYbit)*numInVector/param->numBitInput, 0);
Tile.cpp:				numBitToLoadIn = MAX(ceil(weightMatrixCol/param->numColPerSynapse)*(1+accumulationCM->numAdderBit)*numInVector/param->numBitInput, 0);
Tile.cpp:			int numSubArray = ceil((double) peSize/(double) param->numRowSubArray)*ceil((double) peSize/(double) param->numColSubArray);
Tile.cpp:			accumulationNM->CalculateLatency((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse), numPE, 0);
Tile.cpp:			accumulationNM->CalculatePower((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse), numPE);
Tile.cpp:			if (!param->chipActivation) {
Tile.cpp:				if (param->reLu) {
Tile.cpp:					reLuNM->CalculateLatency((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse)/reLuNM->numUnit);
Tile.cpp:					reLuNM->CalculatePower((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse)/reLuNM->numUnit);
Tile.cpp:					numBitToLoadIn = MAX(ceil(weightMatrixCol/param->numColPerSynapse)*(1+reLuNM->numBit)*numInVector/param->numBitInput/numPE, 0);
Tile.cpp:					sigmoidNM->CalculateLatency((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse)/sigmoidNM->numEntry);
Tile.cpp:					sigmoidNM->CalculatePower((int)(numInVector/param->numBitInput)*ceil(param->numColMuxed/param->numColPerSynapse)/sigmoidNM->numEntry);
Tile.cpp:					numBitToLoadIn = MAX(ceil(weightMatrixCol/param->numColPerSynapse)*(1+sigmoidNM->numYbit)*numInVector/param->numBitInput/numPE, 0);
Tile.cpp:				numBitToLoadIn = MAX(ceil(weightMatrixCol/param->numColPerSynapse)*(1+accumulationNM->numAdderBit)*numInVector/param->numBitInput/numPE, 0);
Tile.cpp:			int numSubArray = ceil((double) peSize/(double) param->numRowSubArray)*ceil((double) peSize/(double) param->numColSubArray);
