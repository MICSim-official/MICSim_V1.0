Adder.cpp:		readLatency = 0;
Adder.cpp:		double readLatencyIntermediate = 0;
Adder.cpp:		readLatency += horowitz(tr, beta, ramp[0], &ramp[1]);
Adder.cpp:		readLatency += horowitz(tr, beta, ramp[1], &ramp[2]);
Adder.cpp:		readLatencyIntermediate += horowitz(tr, beta, ramp[2], &ramp[3]);
Adder.cpp:		readLatencyIntermediate += horowitz(tr, beta, ramp[3], &ramp[4]);
Adder.cpp:			readLatency += readLatencyIntermediate * (numBit - 2);
Adder.cpp:		readLatency += horowitz(tr, beta, ramp[4], &ramp[5]);
Adder.cpp:		readLatency += horowitz(tr, beta, ramp[5], &ramp[6]);
Adder.cpp:		readLatency += horowitz(tr, beta, ramp[6], &ramp[7]);
Adder.cpp:			readLatency  = ceil(readLatency*clkFreq);	//#cycles
Adder.cpp:		readLatency *= numRead;
AdderTree.cpp:		readLatency = 0;
AdderTree.cpp:			readLatency += adder.readLatency;
AdderTree.cpp:        readLatency *= numRead;		
BitShifter.cpp:		readLatency = 0;
BitShifter.cpp:		readLatency += dff.readLatency; // read out parallely
BitShifter.cpp:		readLatency *= numRead;    
Buffer.cpp:		readLatency = 0;
Buffer.cpp:			readLatency = numRead;		// read 1 line per cycle
Buffer.cpp:				readWholeLatency += wlDecoder.readLatency + precharger.readLatency + colDelay;
Buffer.cpp:				readWholeLatency += wlDecoder.readLatency;
Buffer.cpp:			readLatency = avgBitReadLatency*numRead;
Bus.cpp:		readLatency = 0;
Bus.cpp:			readLatency += wireLength*unitLatencyRep;
Bus.cpp:			readLatency += wireLength*unitLatencyWire;
Bus.cpp:			readLatency = ceil(readLatency*clkFreq);
Bus.cpp:		readLatency *= numRead;	
Chip.cpp:							double *readLatency, double *readDynamicEnergy, double *leakage, double *bufferLatency, double *bufferDynamicEnergy, double *icLatency, double *icDynamicEnergy, 
Chip.cpp:	*readLatency = 0;
Chip.cpp:				*readLatency = MAX(tileReadLatency, (*readLatency));
Chip.cpp:					*readLatency += GreLu->readLatency;
Chip.cpp:					*coreLatencyOther += GreLu->readLatency;
Chip.cpp:					*readLatency += Gsigmoid->readLatency;
Chip.cpp:					*coreLatencyOther += Gsigmoid->readLatency;
Chip.cpp:				*readLatency += Gaccumulation->readLatency;
Chip.cpp:				*coreLatencyAccum += Gaccumulation->readLatency;
Chip.cpp:				*readLatency += maxPool->readLatency;
Chip.cpp:				*coreLatencyOther += maxPool->readLatency;
Chip.cpp:			globalBuffer->readLatency /= MIN(numBufferCore, ceil(globalBusWidth/globalBuffer->interface_width));
Chip.cpp:			globalBuffer->readLatency *= ceil(totalNumTile/(numTileEachLayer[0][l]*numTileEachLayer[1][l]));
Chip.cpp:				*readLatency = MAX(tileReadLatency, (*readLatency));
Chip.cpp:					*readLatency += GreLu->readLatency;
Chip.cpp:					*coreLatencyOther += GreLu->readLatency;
Chip.cpp:					*readLatency += Gsigmoid->readLatency;
Chip.cpp:					*coreLatencyOther += Gsigmoid->readLatency;
Chip.cpp:				*readLatency += Gaccumulation->readLatency;
Chip.cpp:				*coreLatencyAccum += Gaccumulation->readLatency;
Chip.cpp:				*readLatency += maxPool->readLatency;
Chip.cpp:				*coreLatencyOther += maxPool->readLatency;
Chip.cpp:			globalBuffer->readLatency /= MIN(numBufferCore, ceil(globalBusWidth/globalBuffer->interface_width));
Chip.cpp:			globalBuffer->readLatency *= ceil(totalNumTile/(numTileEachLayer[0][l]*numTileEachLayer[1][l]));
Chip.cpp:		*bufferLatency += globalBuffer->readLatency + globalBuffer->writeLatency;
Chip.cpp:		*icLatency += GhTree->readLatency;
Chip.cpp:		*readLatency += globalBuffer->readLatency + globalBuffer->writeLatency + GhTree->readLatency;
Chip.cpp:		*coreLatencyOther += globalBuffer->readLatency + globalBuffer->writeLatency + GhTree->readLatency;
Chip.h:							double CMTileheight, double CMTilewidth, double NMTileheight, double NMTilewidth, double *readLatency, double *readDynamicEnergy, 
Comparator.cpp:		readLatency = 0;
Comparator.cpp:		double readLatencyIntermediate = 0;
Comparator.cpp:		readLatency += horowitz(tr, beta, rampInput, &rampNand2Output);
Comparator.cpp:		readLatency += horowitz(tr, beta, rampNand2Output, &rampNand3Output);
Comparator.cpp:		readLatencyIntermediate += horowitz(tr, beta, rampNand3Output, &rampNand2Output);
Comparator.cpp:		readLatencyIntermediate += horowitz(tr, beta, rampNand2Output, &rampNand3Output);
Comparator.cpp:		readLatency += readLatencyIntermediate * (numBit - 2);
Comparator.cpp:		readLatency += horowitz(tr, beta, rampNand3Output, &rampNand2Output);
Comparator.cpp:		readLatency += horowitz(tr, beta, rampNand2Output, &rampNand3Output);
Comparator.cpp:		readLatency *= numRead;
CurrentSenseAmp.cpp:		readLatency = 0;
CurrentSenseAmp.cpp:		readLatency += LatencyCol*numColMuxed;
CurrentSenseAmp.cpp:		readLatency *= numRead;
DecoderDriver.cpp:		readLatency = 0;
DecoderDriver.cpp:		readLatency += horowitz(tr, 0, rampInput, &rampOutput); // get from chargeLatency in the original SubArray.cpp
DecoderDriver.cpp:		readLatency *= numRead;
DecoderDriver.cpp:		if (!readLatency) {
DecoderDriver.cpp:			readPower = readDynamicEnergy/readLatency;
DeMux.cpp:		readLatency = 0;
DeMux.cpp:		readLatency += 2.3 * tr;
DeMux.cpp:		readLatency *= numRead;
DeMux.cpp:		if (!readLatency) {
DeMux.cpp:			readPower = readDynamicEnergy/readLatency;
DFF.cpp:			readLatency = numRead;		//#cycles
DFF.cpp:			readLatency = 1/clkFreq/2;
DFF.cpp:			readLatency *= numRead;
DRAM.cpp:		readLatency = numRead/bandwidth;	
FunctionUnit.cpp:	readLatency = writeLatency = 0;
FunctionUnit.cpp:	cout << " - Read Latency = " << readLatency*1e9 << "ns" << endl;
FunctionUnit.cpp:	outfile << " - Read Latency = " << readLatency*1e9 << "ns" << endl;
FunctionUnit.h:	double readLatency, writeLatency;		/* Unit: s */
HTree.cpp:		readLatency = 0;
HTree.cpp:					readLatency += wireLengthV*unitLatencyRep;
HTree.cpp:					readLatency += wireLengthV*unitLatencyWire;
HTree.cpp:					readLatency += wireLengthH*unitLatencyRep;
HTree.cpp:					readLatency += wireLengthH*unitLatencyWire;
HTree.cpp:			readLatency += min(numCol-x_center, x_center)*unitWidth*unitLatencyRep;
HTree.cpp:				readLatency += wireLengthH*unitLatencyRep;
HTree.cpp:				readLatency += wireLengthH*unitLatencyWire;
HTree.cpp:					readLatency += wireLengthV*unitLatencyRep;
HTree.cpp:					readLatency += wireLengthV*unitLatencyWire;
HTree.cpp:					readLatency += wireLengthV*unitLatencyRep;
HTree.cpp:					readLatency += wireLengthV*unitLatencyWire;
HTree.cpp:					readLatency += wireLengthH*unitLatencyRep;
HTree.cpp:					readLatency += wireLengthH*unitLatencyWire;
HTree.cpp:			readLatency = ceil(readLatency*clkFreq);
HTree.cpp:		readLatency *= numRead; 	
LevelShifter.cpp:		readLatency = 0;
LevelShifter.cpp:		readLatency += horowitz(tr, beta, 1e20, &ramp[0]);
LevelShifter.cpp:		readLatency += horowitz(tr, beta, 1e20, &ramp[1]);
LevelShifter.cpp:		readLatency *= numRead;
main.cpp:			cout << "layer" << i+1 << "'s readLatency is: " << layerReadLatency*1e9 << "ns" << endl;
main.cpp:			cout << "----------- ADC (or S/As and precharger for SRAM) readLatency is : " << coreLatencyADC*1e9 << "ns" << endl;
main.cpp:			cout << "----------- Accumulation Circuits (subarray level: adders, shiftAdds; PE/Tile/Global level: accumulation units) readLatency is : " << coreLatencyAccum*1e9 << "ns" << endl;
main.cpp:			cout << "----------- Other Peripheries (e.g. decoders, mux, switchmatrix, buffers, IC, pooling and activation units) readLatency is : " << coreLatencyOther*1e9 << "ns" << endl;
main.cpp:		vector<double> readLatencyPerLayer;
main.cpp:			readLatencyPerLayer.push_back(layerReadLatency);
main.cpp:			cout << "layer" << i+1 << "'s readLatency is: " << readLatencyPerLayer[i]*1e9 << "ns" << endl;
main.cpp:			cout << "layer" << i+1 << "'s leakageEnergy is: " << leakagePowerPerLayer[i] * (systemClock-readLatencyPerLayer[i]) *1e12 << "pJ" << endl;
main.cpp:			cout << "----------- ADC (or S/As and precharger for SRAM) readLatency is : " << coreLatencyADCPerLayer[i]*1e9 << "ns" << endl;
main.cpp:			cout << "----------- Accumulation Circuits (subarray level: adders, shiftAdds; PE/Tile/Global level: accumulation units) readLatency is : " << coreLatencyAccumPerLayer[i]*1e9 << "ns" << endl;
main.cpp:			cout << "----------- Other Peripheries (e.g. decoders, mux, switchmatrix, buffers, IC, pooling and activation units) readLatency is : " << coreLatencyOtherPerLayer[i]*1e9 << "ns" << endl;
main.cpp:			chipLeakageEnergy += leakagePowerPerLayer[i] * (systemClock-readLatencyPerLayer[i]);
main.cpp:		cout << "Chip layer-by-layer readLatency (per image) is: " << chipReadLatency*1e9 << "ns" << endl;
main.cpp:		cout << "Chip buffer readLatency is: " << chipbufferLatency*1e9 << "ns" << endl;
main.cpp:		cout << "Chip ic readLatency is: " << chipicLatency*1e9 << "ns" << endl;
main.cpp:		cout << "Chip pipeline-system buffer readLatency (per image) is: " << chipbufferLatency*1e9 << "ns" << endl;
main.cpp:		cout << "Chip pipeline-system ic readLatency (per image) is: " << chipicLatency*1e9 << "ns" << endl;
main.cpp:	cout << "----------- ADC (or S/As and precharger for SRAM) readLatency is : " << chipLatencyADC*1e9 << "ns" << endl;
main.cpp:	cout << "----------- Accumulation Circuits (subarray level: adders, shiftAdds; PE/Tile/Global level: accumulation units) readLatency is : " << chipLatencyAccum*1e9 << "ns" << endl;
main.cpp:	cout << "----------- Other Peripheries (e.g. decoders, mux, switchmatrix, buffers, IC, pooling and activation units) readLatency is : " << chipLatencyOther*1e9 << "ns" << endl;
MaxPooling.cpp:		readLatency = 0;
MaxPooling.cpp:		readLatency += comparator.readLatency * numBit/2;    // assume the comparator will go to the half way and stop
MaxPooling.cpp:		readLatency += horowitz(tr, beta, 1e20, &rampNOROutput);
MaxPooling.cpp:		readLatency += horowitz(tr, beta, 1e20, &rampINVOutput);
MaxPooling.cpp:		readLatency += horowitz(tr, beta, rampINVOutput, &rampTGOutput);
MaxPooling.cpp:			readLatency = ceil(readLatency*clkFreq);
MaxPooling.cpp:		readLatency *= numStage;
MaxPooling.cpp:		readLatency *= numRead;
MultilevelSAEncoder.cpp:		readLatency = 0;
MultilevelSAEncoder.cpp:		double readLatencyIntermediate = 0;
MultilevelSAEncoder.cpp:		readLatency += horowitz(tr, beta, ramp[0], &ramp[1]);
MultilevelSAEncoder.cpp:		readLatency += horowitz(tr, beta, ramp[1], &ramp[2]);
MultilevelSAEncoder.cpp:		readLatencyIntermediate += horowitz(tr, beta, ramp[2], &ramp[3]);
MultilevelSAEncoder.cpp:		readLatencyIntermediate += horowitz(tr, beta, ramp[3], &ramp[4]);
MultilevelSAEncoder.cpp:		readLatency *= numRead;
MultilevelSAEncoder.cpp:		if (!readLatency) {
MultilevelSAEncoder.cpp:			readPower = readDynamicEnergy/readLatency;
MultilevelSenseAmp.cpp:		readLatency = 0;
MultilevelSenseAmp.cpp:			readLatency = LatencyCol*numColMuxed;
MultilevelSenseAmp.cpp:			readLatency *= numRead;
MultilevelSenseAmp.cpp:			readLatency = (1e-9)*numColMuxed;
MultilevelSenseAmp.cpp:			readLatency *= numRead;
Multiplier.cpp:        readLatency = 0;
Multiplier.cpp:        double readLatencyIntermediate = 0;
Multiplier.cpp:        double readLatency_1 = 0;
Multiplier.cpp:        double readLatency_2 = 0;
Multiplier.cpp:        readLatency_1 += horowitz(tr, beta, ramp[0], &ramp[1]);
Multiplier.cpp:        readLatency_1 += horowitz(tr, beta, ramp[1], &ramp[2]);
Multiplier.cpp:        readLatency_1 += horowitz(tr, beta, ramp[2], &ramp[3]);
Multiplier.cpp:        readLatencyIntermediate += horowitz(tr, beta, ramp[3], &ramp[4]);
Multiplier.cpp:        readLatencyIntermediate += horowitz(tr, beta, ramp[4], &ramp[5]);
Multiplier.cpp:            readLatency_1 += readLatencyIntermediate * (numBit - 2);
Multiplier.cpp:        readLatency_1 += horowitz(tr, beta, ramp[5], &ramp[6]);
Multiplier.cpp:        readLatency_1 += horowitz(tr, beta, ramp[6], &ramp[7]);
Multiplier.cpp:        readLatency_1 += horowitz(tr, beta, ramp[7], &ramp[8]);
Multiplier.cpp:            readLatency_2 += horowitz(tr, beta, ramp[8], &ramp[9]);
Multiplier.cpp:            readLatency_2 += horowitz(tr, beta, ramp[9], &ramp[10]);
Multiplier.cpp:            readLatency_2 += horowitz(tr, beta, ramp[10], &ramp[11]);
Multiplier.cpp:            readLatencyIntermediate += horowitz(tr, beta, ramp[11], &ramp[12]);
Multiplier.cpp:            readLatencyIntermediate += horowitz(tr, beta, ramp[12], &ramp[13]);
Multiplier.cpp:                readLatency_2 += readLatencyIntermediate * (numBit - 2);
Multiplier.cpp:            readLatency_2 += horowitz(tr, beta, ramp[13], &ramp[14]);
Multiplier.cpp:            readLatency_2 += horowitz(tr, beta, ramp[14], &ramp[15]);
Multiplier.cpp:            readLatency_2 += horowitz(tr, beta, ramp[15], &ramp[16]);
Multiplier.cpp:            readLatency = readLatency_1*0.5*(numBit-1) + readLatency_2*0.5*(numBit-1);
Multiplier.cpp:            readLatency = readLatency_1*numBit;
Multiplier.cpp:        readLatency *= numRead;
Multiplier.cpp:        // if (!readLatency) {
Multiplier.cpp:        // readPower = readDynamicEnergy/readLatency;
Mux.cpp:		readLatency = 0;
Mux.cpp:		readLatency += 2.3 * tr;	// 2.3 means charging from 0% to 90%
Mux.cpp:		readLatency *= numRead;
neurosim.cpp:            .def_readwrite("readLatency", &Bus::readLatency);
neurosim.cpp:            .def_readwrite("readLatency", &SubArray::readLatency)
neurosim.cpp:            .def_readwrite("readLatency", &Mux::readLatency);
neurosim.cpp:            .def_readwrite("readLatency", &RowDecoder::readLatency);
neurosim.cpp:            .def_readwrite("readLatency", &RowDecoder::readLatency);
neurosim.cpp:            .def_readwrite("readLatency", &Adder::readLatency)
neurosim.cpp:            .def_readwrite("readLatency", &AdderTree::readLatency)
neurosim.cpp:            .def_readwrite("readLatency", &ShiftAdd::readLatency)
neurosim.cpp:            .def_readwrite("readLatency", &DFF::readLatency)
neurosim.cpp:            .def_readwrite("readLatency", &DRAM::readLatency)
neurosim.cpp:            .def_readwrite("readLatency", &Buffer::readLatency)
neurosim.cpp:            .def_readwrite("readLatency", &HTree::readLatency)
neurosim.cpp:            .def_readwrite("readLatency", &BitShifter::readLatency)
neurosim.cpp:            .def_readwrite("readLatency", &MaxPooling::readLatency)
neurosim.cpp:            .def_readwrite("readLatency", &MultilevelSAEncoder::readLatency)
neurosim.cpp:            .def_readwrite("readLatency", &MultilevelSenseAmp::readLatency)
NewMux.cpp:		readLatency = 0;
NewMux.cpp:		readLatency += 2.3 * tr;	// 2.3 means charging from 0% to 90%
NewMux.cpp:		readLatency *= numRead;
NewSwitchMatrix.cpp:		readLatency = 0;
NewSwitchMatrix.cpp:		readLatency += horowitz(tr, 0, rampInput, &rampOutput);	// get from chargeLatency in the original SubArray.cpp
NewSwitchMatrix.cpp:		readLatency *= numRead;
NewSwitchMatrix.cpp:		// readLatency += dff.readLatency;
NewSwitchMatrix.cpp:		    writeLatency += dff.readLatency;	// Use DFF read latency here because no write in the DFF module
numColPerSynapse:SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
numColPerSynapse:SubArray.cpp:						readLatencyADC = (precharger.readLatency + colDelay + senseAmp.readLatency) * numReadOperationPerRow*numRow*activityRowRead * (validated==true? param->beta : 1);;
numColPerSynapse:SubArray.cpp:						readLatencyOther = wlDecoder.readLatency * numRow*activityRowRead * (validated==true? param->beta : 1);;
numColPerSynapse:SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
numColPerSynapse:SubArray.cpp:						readLatencyADC = (precharger.readLatency + colDelay + multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency) * numColMuxed * (validated==true? param->beta : 1);
numColPerSynapse:SubArray.cpp:						readLatencyOther = MAX(wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0) ) * numColMuxed * (validated==true? param->beta : 1);
numColPerSynapse:SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
numColPerSynapse:SubArray.cpp:						readLatencyADC = (precharger.readLatency + colDelay + senseAmp.readLatency) * numReadOperationPerRow*numRow*activityRowRead * (validated==true? param->beta : 1);;
numColPerSynapse:SubArray.cpp:						readLatencyOther = wlDecoder.readLatency * numRow*activityRowRead * (validated==true? param->beta : 1);;
numColPerSynapse:SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
numColPerSynapse:SubArray.cpp:						readLatencyADC = (precharger.readLatency + colDelay + multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency) * numColMuxed * (validated==true? param->beta : 1);;
numColPerSynapse:SubArray.cpp:						readLatencyOther = MAX(wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0) ) * numColMuxed * (validated==true? param->beta : 1);;
numColPerSynapse:SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);		// latency factor of sensing cycle, beta = 1.4 by default
numColPerSynapse:SubArray.cpp:						readLatencyADC = (multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency + colDelay) * (numRow*activityRowRead*numColMuxed) * (validated==true? param->beta : 1);
numColPerSynapse:SubArray.cpp:						readLatencyOther = MAX((wlDecoder.readLatency + wlNewDecoderDriver.readLatency + wlDecoderDriver.readLatency)*numRow*activityRowRead, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
numColPerSynapse:SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default									
numColPerSynapse:SubArray.cpp:						readLatencyADC = (multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency + colDelay) * numColMuxed * (validated==true? param->beta : 1);
numColPerSynapse:SubArray.cpp:						readLatencyOther = MAX(wlNewSwitchMatrix.readLatency + wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
numColPerSynapse:SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
numColPerSynapse:SubArray.cpp:						readLatencyADC = (rowCurrentSenseAmp.readLatency + colDelay) * numRow*activityRowRead*numColMuxed * (validated==true? param->beta : 1);
numColPerSynapse:SubArray.cpp:						readLatencyOther = MAX((wlDecoder.readLatency + wlNewDecoderDriver.readLatency + wlDecoderDriver.readLatency)*numRow*activityRowRead, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
numColPerSynapse:SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
numColPerSynapse:SubArray.cpp:						readLatencyADC = (multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency + colDelay) * numColMuxed * (validated==true? param->beta : 1);
numColPerSynapse:SubArray.cpp:						readLatencyOther = MAX(wlNewSwitchMatrix.readLatency + wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
Precharger.cpp:		readLatency = 0;
Precharger.cpp:		readLatency += horowitz(tau, beta, 1e20, &rampOutput);
Precharger.cpp:		writeLatency = readLatency;
Precharger.cpp:		readLatency *= numRead;
ProcessingUnit.cpp:											int weightMatrixCol, int numInVector, MemCell& cell, bool NMpe, double *readLatency, double *readDynamicEnergy, double *leakage, 
ProcessingUnit.cpp:	*readLatency = 0;
ProcessingUnit.cpp:							if(CalculateclkFreq && (*clkPeriod < subArray->readLatency)){
ProcessingUnit.cpp:								*clkPeriod = subArray->readLatency;					//clk freq is decided by the longest sensing latency
ProcessingUnit.cpp:								subArrayLatencyADC += subArray->readLatencyADC;			//sensing cycle
ProcessingUnit.cpp:								subArrayLatencyAccum += subArray->readLatencyAccum;		//#cycles
ProcessingUnit.cpp:								subArrayReadLatency += subArray->readLatency;		//#cycles + sensing cycle
ProcessingUnit.cpp:								subArrayLatencyOther += subArray->readLatencyOther;		
ProcessingUnit.cpp:							*readLatency = MAX(subArrayReadLatency + adderTreeNM->readLatency, (*readLatency));
ProcessingUnit.cpp:							*coreLatencyAccum = MAX(subArrayLatencyAccum + adderTreeNM->readLatency, (*coreLatencyAccum));
ProcessingUnit.cpp:							*readLatency = MAX(subArrayReadLatency + adderTreeCM->readLatency, (*readLatency));
ProcessingUnit.cpp:							*coreLatencyAccum = MAX(subArrayLatencyAccum + adderTreeCM->readLatency, (*coreLatencyAccum));
ProcessingUnit.cpp:			*readLatency = (*readLatency)/(arrayDupRow*arrayDupCol);
ProcessingUnit.cpp:				if(CalculateclkFreq && (*clkPeriod < subArray->readLatency)){
ProcessingUnit.cpp:					*clkPeriod = subArray->readLatency;					//clk freq is decided by the longest sensing latency
ProcessingUnit.cpp:					subArrayLatencyADC += subArray->readLatencyADC;			//sensing cycle
ProcessingUnit.cpp:					subArrayLatencyAccum += subArray->readLatencyAccum;		//#cycles
ProcessingUnit.cpp:					subArrayReadLatency += subArray->readLatency;		//#cycles + sensing cycle
ProcessingUnit.cpp:					subArrayLatencyOther += subArray->readLatencyOther;
ProcessingUnit.cpp:			*readLatency = subArrayReadLatency/(arrayDupRow*arrayDupCol);
ProcessingUnit.cpp:						if(CalculateclkFreq && (*clkPeriod < subArray->readLatency)){
ProcessingUnit.cpp:							*clkPeriod = subArray->readLatency;					//clk freq is decided by the longest sensing latency
ProcessingUnit.cpp:							subArrayLatencyADC += subArray->readLatencyADC;			//sensing cycle
ProcessingUnit.cpp:							subArrayLatencyAccum += subArray->readLatencyAccum;		//#cycles
ProcessingUnit.cpp:							subArrayReadLatency += subArray->readLatency;		//#cycles + sensing cycle
ProcessingUnit.cpp:							subArrayLatencyOther += subArray->readLatencyOther;
ProcessingUnit.cpp:					*readLatency = MAX(subArrayReadLatency, (*readLatency));
ProcessingUnit.cpp:			*readLatency += adderTreeNM->readLatency;
ProcessingUnit.cpp:			*coreLatencyAccum += adderTreeNM->readLatency;
ProcessingUnit.cpp:			*readLatency += adderTreeCM->readLatency;
ProcessingUnit.cpp:			*coreLatencyAccum += adderTreeCM->readLatency;
ProcessingUnit.cpp:			*bufferLatency = bufferInputNM->readLatency + bufferOutputNM->readLatency;	//considered in ic
ProcessingUnit.cpp:				*icLatency = busInputNM->readLatency + busOutputNM->readLatency;	
ProcessingUnit.cpp:			*bufferLatency = bufferInputCM->readLatency + bufferOutputCM->readLatency;	//considered in ic
ProcessingUnit.cpp:				*icLatency = busInputCM->readLatency + busOutputCM->readLatency;	
ProcessingUnit.cpp:		*readLatency += (*bufferLatency) + (*icLatency);	
ProcessingUnit.h:										int numInVector, MemCell& cell, bool NMpe, double *readLatency, double *readDynamicEnergy, double *leakage, 
pyNeuroSim.cpp:            .def_readwrite("readLatency", &SubArray::readLatency)
pyNeuroSim.cpp:            //.def_readwrite("readLatencyAG", &SubArray::readLatencyAG)
pyNeuroSim.cpp:            .def_readwrite("readLatency", &SubArray::readLatency)
pyNeuroSim.cpp:            //.def_readwrite("readLatencyAG", &SubArray::readLatencyAG)
pyNeuroSim.cpp:            .def_readwrite("readLatency", &Adder::readLatency)
pyNeuroSim.cpp:            .def_readwrite("readLatency", &AdderTree::readLatency)
pyNeuroSim.cpp:            .def_readwrite("readLatency", &ShiftAdd::readLatency)
pyNeuroSim.cpp:            .def_readwrite("readLatency", &DFF::readLatency)
pyNeuroSim.cpp:            .def_readwrite("readLatency", &DRAM::readLatency)
pyNeuroSim.cpp:            .def_readwrite("readLatency", &Buffer::readLatency)
pyNeuroSim.cpp:            .def_readwrite("readLatency", &Bus::readLatency)
pyNeuroSim.cpp:            .def_readwrite("readLatency", &HTree::readLatency)
pyNeuroSim.cpp:            .def_readwrite("readLatency", &BitShifter::readLatency)
pyNeuroSim.cpp:            .def_readwrite("readLatency", &Multiplier::readLatency)
pyNeuroSim.cpp:            .def_readwrite("readLatency", &MaxPooling::readLatency)
pyNeuroSim.cpp:    //        .def_readwrite("readLatency", &WeightGradientUnit::readLatency)
ReadCircuit.cpp:		readLatency = 0;
ReadCircuit.cpp:		readLatency += cell.readPulseWidth;
ReadCircuit.cpp:		readLatency += 1/clkFreq;
ReadCircuit.cpp:		readLatency *= numRead;
RecfgAdderTree.cpp:		readLatency = 0;
RecfgAdderTree.cpp:			readLatency += (adder.readLatency+demux.readLatency);
RecfgAdderTree.cpp:			readLatency = max(readLatency, muxDecoder.readLatency);
RecfgAdderTree.cpp:			readLatency += mux.readLatency;
RecfgAdderTree.cpp:		readLatency += (mux.readLatency+demux.readLatency);
RecfgAdderTree.cpp:		// cout<<"RecfgGaccumulation->readLatency: "<<readLatency<<endl;
RecfgAdderTree.cpp:        readLatency *= numRead;		
RowDecoder.cpp:		readLatency = 0;
RowDecoder.cpp:		readLatency += horowitz(tr, beta, rampInput, &rampInvOutput);
RowDecoder.cpp:			readLatency += horowitz(tr, beta, rampInvOutput, &rampNandOutput);
RowDecoder.cpp:			readLatency += horowitz(tr, beta, rampNandOutput, &rampNorOutput);
RowDecoder.cpp:			readLatency += horowitz(tr, beta, rampNorOutput, &rampNandOutput);
RowDecoder.cpp:			readLatency += horowitz(tr, beta, rampNandOutput, &rampInvOutput);
RowDecoder.cpp:			readLatency += horowitz(tr, beta, rampInvOutput, &rampOutput);
RowDecoder.cpp:			readLatency += horowitz(tr, beta, rampNorOutput, &rampInvOutput);
RowDecoder.cpp:			readLatency += horowitz(tr, beta, rampInvOutput, &rampOutput);
RowDecoder.cpp:		readLatency *= numRead;
SarADC.cpp:		readLatency = 0;
SarADC.cpp:		readLatency += (log2(levelOutput)+1)*1e-9;
SarADC.cpp:		readLatency *= numRead;
SenseAmp.cpp:		readLatency = 0;
SenseAmp.cpp:		readLatency += tau * log(tech.vdd / senseVoltage);
SenseAmp.cpp:		// readLatency += 1/clkFreq;   // Clock time for S/A enable
SenseAmp.cpp:		readLatency *= numRead;
ShiftAdd.cpp:		readLatency = 0;
ShiftAdd.cpp:				readLatency = numRead; 	// #cycles
ShiftAdd.cpp:				double shiftAddLatency = adder.readLatency + dff.readLatency;
ShiftAdd.cpp:					readLatency += (shiftAddLatency - cell.readPulseWidth) * (numRead - 1);
ShiftAdd.cpp:				readLatency += shiftAddLatency;    // At least need one time of shift-and-add
ShiftAdd.cpp:				cout<<"readLatency " << readLatency<<endl;
ShiftAdd.cpp:				readLatency = numBitPerDff * numRead;	// #cycles
ShiftAdd.cpp:				double shiftLatency = dff.readLatency;
ShiftAdd.cpp:					readLatency += (shiftLatency - cell.readPulseWidth) * (numRead - 1);
ShiftAdd.cpp:				readLatency += shiftLatency;	// At least need one time of shiftout
Sigmoid.cpp:		readLatency = 0;
Sigmoid.cpp:			readLatency = wlDecoder.readLatency + senseAmp.readLatency;
Sigmoid.cpp:			readLatency = wlDecoder.readLatency + voltageSenseAmp.readLatency;
Sigmoid.cpp:			readLatency = ceil(readLatency*clkFreq);
Sigmoid.cpp:		readLatency *= numRead;
SramNewSA.cpp:		readLatency = 0;
SramNewSA.cpp:		readLatency = 0.1e-9;
SramNewSA.cpp:		readLatency *= numRead;
SubArray_bu.cpp:		readLatency = 0;
SubArray_bu.cpp:		readLatencyADC = 0;
SubArray_bu.cpp:		readLatencyAccum = 0;
SubArray_bu.cpp:		readLatencyOther = 0;
SubArray_bu.cpp:						readLatency += wlDecoder.readLatency;
SubArray_bu.cpp:						readLatency += precharger.readLatency;
SubArray_bu.cpp:						readLatency += colDelay;
SubArray_bu.cpp:						readLatency += senseAmp.readLatency;
SubArray_bu.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray_bu.cpp:						readLatencyADC = numReadOperationPerRow*numRow*activityRowRead;
SubArray_bu.cpp:						readLatencyAccum = adder.readLatency + shiftAddInput.readLatency + shiftAddWeight.readLatency;
SubArray_bu.cpp:						readLatencyADC = (precharger.readLatency + colDelay + senseAmp.readLatency) * numReadOperationPerRow*numRow*activityRowRead * (validated==true? param->beta : 1);;
SubArray_bu.cpp:						readLatencyAccum = adder.readLatency + dff.readLatency + shiftAddInput.readLatency + shiftAddWeight.readLatency;
SubArray_bu.cpp:						readLatencyOther = wlDecoder.readLatency * numRow*activityRowRead * (validated==true? param->beta : 1);;
SubArray_bu.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray_bu.cpp:						readLatency += MAX(wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0) );
SubArray_bu.cpp:						readLatency += precharger.readLatency;
SubArray_bu.cpp:						readLatency += colDelay;
SubArray_bu.cpp:						readLatency += multilevelSenseAmp.readLatency;
SubArray_bu.cpp:						readLatency += multilevelSAEncoder.readLatency;
SubArray_bu.cpp:						readLatency += sarADC.readLatency;
SubArray_bu.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray_bu.cpp:						readLatencyADC = numColMuxed;						
SubArray_bu.cpp:						readLatencyADC = (precharger.readLatency + colDelay + multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency) * numColMuxed * (validated==true? param->beta : 1);
SubArray_bu.cpp:						readLatencyOther = MAX(wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0) ) * numColMuxed * (validated==true? param->beta : 1);
SubArray_bu.cpp:					readLatencyAccum = shiftAddWeight.readLatency + shiftAddInput.readLatency;
SubArray_bu.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray_bu.cpp:						readLatency += wlDecoder.readLatency;
SubArray_bu.cpp:						readLatency += precharger.readLatency;
SubArray_bu.cpp:						readLatency += colDelay;
SubArray_bu.cpp:						readLatency += senseAmp.readLatency;
SubArray_bu.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray_bu.cpp:						readLatencyADC = numReadOperationPerRow*numRow*activityRowRead;
SubArray_bu.cpp:						readLatencyAccum = adder.readLatency;
SubArray_bu.cpp:						readLatencyADC = (precharger.readLatency + colDelay + senseAmp.readLatency) * numReadOperationPerRow*numRow*activityRowRead * (validated==true? param->beta : 1);;
SubArray_bu.cpp:						readLatencyAccum = adder.readLatency + dff.readLatency;
SubArray_bu.cpp:						readLatencyOther = wlDecoder.readLatency * numRow*activityRowRead * (validated==true? param->beta : 1);;
SubArray_bu.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray_bu.cpp:						readLatency += wlSwitchMatrix.readLatency;
SubArray_bu.cpp:						readLatency += precharger.readLatency;
SubArray_bu.cpp:						readLatency += colDelay;
SubArray_bu.cpp:						readLatency += multilevelSenseAmp.readLatency;
SubArray_bu.cpp:						readLatency += multilevelSAEncoder.readLatency;
SubArray_bu.cpp:						readLatency += sarADC.readLatency;
SubArray_bu.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray_bu.cpp:						readLatencyADC = numColMuxed;
SubArray_bu.cpp:						readLatencyADC = (precharger.readLatency + colDelay + multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency) * numColMuxed * (validated==true? param->beta : 1);;
SubArray_bu.cpp:						readLatencyOther = MAX(wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0) ) * numColMuxed * (validated==true? param->beta : 1);;
SubArray_bu.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray_bu.cpp:						readLatency += MAX(wlDecoder.readLatency + wlNewDecoderDriver.readLatency + wlDecoderDriver.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0));
SubArray_bu.cpp:						readLatency += colDelay;
SubArray_bu.cpp:						readLatency += multilevelSenseAmp.readLatency;
SubArray_bu.cpp:						readLatency += multilevelSAEncoder.readLatency;
SubArray_bu.cpp:						readLatency += sarADC.readLatency;
SubArray_bu.cpp:						readLatency *= (validated==true? param->beta : 1);		// latency factor of sensing cycle, beta = 1.4 by default
SubArray_bu.cpp:						readLatencyADC = numRow*activityRowRead*numColMuxed;
SubArray_bu.cpp:						readLatencyAccum = adder.readLatency + shiftAddWeight.readLatency + shiftAddInput.readLatency;
SubArray_bu.cpp:						readLatencyADC = (multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency + colDelay) * (numRow*activityRowRead*numColMuxed) * (validated==true? param->beta : 1);
SubArray_bu.cpp:						readLatencyAccum = adder.readLatency + dff.readLatency + shiftAddWeight.readLatency + shiftAddInput.readLatency;	
SubArray_bu.cpp:						readLatencyOther = MAX((wlDecoder.readLatency + wlNewDecoderDriver.readLatency + wlDecoderDriver.readLatency)*numRow*activityRowRead, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
SubArray_bu.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray_bu.cpp:						readLatency += MAX(wlNewSwitchMatrix.readLatency + wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0));
SubArray_bu.cpp:						readLatency += colDelay;
SubArray_bu.cpp:						readLatency += multilevelSenseAmp.readLatency;
SubArray_bu.cpp:						readLatency += multilevelSAEncoder.readLatency;
SubArray_bu.cpp:						readLatency += sarADC.readLatency;
SubArray_bu.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default									
SubArray_bu.cpp:						readLatencyADC = numColMuxed;
SubArray_bu.cpp:						readLatencyADC = (multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency + colDelay) * numColMuxed * (validated==true? param->beta : 1);
SubArray_bu.cpp:						readLatencyOther = MAX(wlNewSwitchMatrix.readLatency + wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
SubArray_bu.cpp:					readLatencyAccum = shiftAddWeight.readLatency + shiftAddInput.readLatency;
SubArray_bu.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray_bu.cpp:						readLatency += MAX(wlDecoder.readLatency + wlNewDecoderDriver.readLatency + wlDecoderDriver.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0));
SubArray_bu.cpp:						readLatency += colDelay;
SubArray_bu.cpp:						readLatency += rowCurrentSenseAmp.readLatency;
SubArray_bu.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray_bu.cpp:						readLatencyADC = numRow*activityRowRead*numColMuxed;
SubArray_bu.cpp:						readLatencyAccum = adder.readLatency;
SubArray_bu.cpp:						readLatencyADC = (rowCurrentSenseAmp.readLatency + colDelay) * numRow*activityRowRead*numColMuxed * (validated==true? param->beta : 1);
SubArray_bu.cpp:						readLatencyAccum = adder.readLatency + dff.readLatency;
SubArray_bu.cpp:						readLatencyOther = MAX((wlDecoder.readLatency + wlNewDecoderDriver.readLatency + wlDecoderDriver.readLatency)*numRow*activityRowRead, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
SubArray_bu.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray_bu.cpp:						readLatency += MAX(wlNewSwitchMatrix.readLatency + wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0));
SubArray_bu.cpp:						readLatency += colDelay;
SubArray_bu.cpp:						readLatency += multilevelSenseAmp.readLatency;
SubArray_bu.cpp:						readLatency += multilevelSAEncoder.readLatency;
SubArray_bu.cpp:						readLatency += sarADC.readLatency;
SubArray_bu.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray_bu.cpp:						readLatencyADC = numColMuxed;
SubArray_bu.cpp:						readLatencyADC = (multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency + colDelay) * numColMuxed * (validated==true? param->beta : 1);
SubArray_bu.cpp:						readLatencyOther = MAX(wlNewSwitchMatrix.readLatency + wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
SubArray_bu.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray_bu.h:	double areaADC, areaAccum, areaOther, readLatencyADC, readLatencyAccum, readLatencyOther, readDynamicEnergyADC, readDynamicEnergyAccum, readDynamicEnergyOther;
SubArray.cpp:		readLatency = 0;
SubArray.cpp:		readLatencyADC = 0;
SubArray.cpp:		readLatencyAccum = 0;
SubArray.cpp:		readLatencyOther = 0;
SubArray.cpp:						readLatency += wlDecoder.readLatency;
SubArray.cpp:						readLatency += precharger.readLatency;
SubArray.cpp:						readLatency += colDelay;
SubArray.cpp:						readLatency += senseAmp.readLatency;
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray.cpp:						readLatencyADC = numReadOperationPerRow*numRow*activityRowRead;
SubArray.cpp:						readLatencyAccum = adder.readLatency + shiftAddInput.readLatency + shiftAddWeight.readLatency;
SubArray.cpp:						readLatencyADC = (precharger.readLatency + colDelay + senseAmp.readLatency) * numReadOperationPerRow*numRow*activityRowRead * (validated==true? param->beta : 1);;
SubArray.cpp:						readLatencyAccum = adder.readLatency + dff.readLatency + shiftAddInput.readLatency + shiftAddWeight.readLatency;
SubArray.cpp:						readLatencyOther = wlDecoder.readLatency * numRow*activityRowRead * (validated==true? param->beta : 1);;
SubArray.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray.cpp:						readLatency += MAX(wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0) );
SubArray.cpp:						readLatency += precharger.readLatency;
SubArray.cpp:						readLatency += colDelay;
SubArray.cpp:						readLatency += multilevelSenseAmp.readLatency;
SubArray.cpp:						readLatency += multilevelSAEncoder.readLatency;
SubArray.cpp:						readLatency += sarADC.readLatency;
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray.cpp:						readLatencyADC = numColMuxed;						
SubArray.cpp:						readLatencyADC = (precharger.readLatency + colDelay + multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:						readLatencyOther = MAX(wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0) ) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:					readLatencyAccum = shiftAddWeight.readLatency + shiftAddInput.readLatency;
SubArray.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray.cpp:						readLatency += wlDecoder.readLatency;
SubArray.cpp:						readLatency += precharger.readLatency;
SubArray.cpp:						readLatency += colDelay;
SubArray.cpp:						readLatency += senseAmp.readLatency;
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray.cpp:						readLatencyADC = numReadOperationPerRow*numRow*activityRowRead;
SubArray.cpp:						readLatencyAccum = adder.readLatency;
SubArray.cpp:						readLatencyADC = (precharger.readLatency + colDelay + senseAmp.readLatency) * numReadOperationPerRow*numRow*activityRowRead * (validated==true? param->beta : 1);;
SubArray.cpp:						readLatencyAccum = adder.readLatency + dff.readLatency;
SubArray.cpp:						readLatencyOther = wlDecoder.readLatency * numRow*activityRowRead * (validated==true? param->beta : 1);;
SubArray.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray.cpp:						readLatency += wlSwitchMatrix.readLatency;
SubArray.cpp:						readLatency += precharger.readLatency;
SubArray.cpp:						readLatency += colDelay;
SubArray.cpp:						readLatency += multilevelSenseAmp.readLatency;
SubArray.cpp:						readLatency += multilevelSAEncoder.readLatency;
SubArray.cpp:						readLatency += sarADC.readLatency;
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray.cpp:						readLatencyADC = numColMuxed;
SubArray.cpp:						readLatencyADC = (precharger.readLatency + colDelay + multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency) * numColMuxed * (validated==true? param->beta : 1);;
SubArray.cpp:						readLatencyOther = MAX(wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0) ) * numColMuxed * (validated==true? param->beta : 1);;
SubArray.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray.cpp:						readLatency += MAX(wlDecoder.readLatency + wlNewDecoderDriver.readLatency + wlDecoderDriver.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0));
SubArray.cpp:						readLatency += colDelay;
SubArray.cpp:						readLatency += multilevelSenseAmp.readLatency;
SubArray.cpp:						readLatency += multilevelSAEncoder.readLatency;
SubArray.cpp:						readLatency += sarADC.readLatency;
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);		// latency factor of sensing cycle, beta = 1.4 by default
SubArray.cpp:						readLatencyADC = numRow*activityRowRead*numColMuxed;
SubArray.cpp:						readLatencyAccum = adder.readLatency + shiftAddWeight.readLatency + shiftAddInput.readLatency;
SubArray.cpp:						readLatencyADC = (multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency + colDelay) * (numRow*activityRowRead*numColMuxed) * (validated==true? param->beta : 1);
SubArray.cpp:						readLatencyAccum = adder.readLatency + dff.readLatency + shiftAddWeight.readLatency + shiftAddInput.readLatency;	
SubArray.cpp:						readLatencyOther = MAX((wlDecoder.readLatency + wlNewDecoderDriver.readLatency + wlDecoderDriver.readLatency)*numRow*activityRowRead, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray.cpp:						readLatency += MAX(wlNewSwitchMatrix.readLatency + wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0));
SubArray.cpp:						readLatency += colDelay;
SubArray.cpp:						readLatency += multilevelSenseAmp.readLatency;
SubArray.cpp:						readLatency += multilevelSAEncoder.readLatency;
SubArray.cpp:						readLatency += sarADC.readLatency + ((ADCmode==2)==true?(LUDecoder.readLatency + LUBuffer.readLatency):0);
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default									
SubArray.cpp:						readLatencyADC = numColMuxed;
SubArray.cpp:						readLatencyADC = (multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency + ((ADCmode==2)==true?(LUDecoder.readLatency + LUBuffer.readLatency):0) + colDelay) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:						 cout<<"inside subarray readLatencyADC "<<multilevelSenseAmp.readLatency <<" "<< multilevelSAEncoder.readLatency<<" "<<sarADC.readLatency<< " " <<LUDecoder.readLatency<<endl;
SubArray.cpp:						readLatencyOther = MAX(wlNewSwitchMatrix.readLatency + wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:					    cout<<"inside subarray readLatencyOther "<<wlNewSwitchMatrix.readLatency <<" "<< wlSwitchMatrix.readLatency<<" "<<mux.readLatency<< " " <<muxDecoder.readLatency<<endl;
SubArray.cpp:					cout<<"inside subarray"<<readLatencyADC <<" "<< readLatencyAccum <<" "<< readLatencyOther << endl;
SubArray.cpp:					readLatencyAccum = /*shiftAddWeight.readLatency/numReadPulse +*/ shiftAddInput.readLatency + ((WeDummyCol>0) == true ? dummyAdd.readLatency:0);
SubArray.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray.cpp:						readLatency += MAX(wlDecoder.readLatency + wlNewDecoderDriver.readLatency + wlDecoderDriver.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0));
SubArray.cpp:						readLatency += colDelay;
SubArray.cpp:						readLatency += rowCurrentSenseAmp.readLatency;
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray.cpp:						readLatencyADC = numRow*activityRowRead*numColMuxed;
SubArray.cpp:						readLatencyAccum = adder.readLatency;
SubArray.cpp:						readLatencyADC = (rowCurrentSenseAmp.readLatency + colDelay) * numRow*activityRowRead*numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:						readLatencyAccum = adder.readLatency + dff.readLatency;
SubArray.cpp:						readLatencyOther = MAX((wlDecoder.readLatency + wlNewDecoderDriver.readLatency + wlDecoderDriver.readLatency)*numRow*activityRowRead, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray.cpp:						readLatency += MAX(wlNewSwitchMatrix.readLatency + wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0));
SubArray.cpp:						readLatency += colDelay;
SubArray.cpp:						readLatency += multilevelSenseAmp.readLatency;
SubArray.cpp:						readLatency += multilevelSAEncoder.readLatency;
SubArray.cpp:						readLatency += sarADC.readLatency;
SubArray.cpp:						readLatency *= (validated==true? param->beta : 1);	// latency factor of sensing cycle, beta = 1.4 by default
SubArray.cpp:						readLatencyADC = numColMuxed;
SubArray.cpp:						readLatencyADC = (multilevelSenseAmp.readLatency + multilevelSAEncoder.readLatency + sarADC.readLatency + colDelay) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:						readLatencyOther = MAX(wlNewSwitchMatrix.readLatency + wlSwitchMatrix.readLatency, ((numColMuxed > 1)==true? (mux.readLatency+muxDecoder.readLatency):0)) * numColMuxed * (validated==true? param->beta : 1);
SubArray.cpp:					readLatency = readLatencyADC + readLatencyAccum + readLatencyOther;
SubArray.h:	double areaADC, areaAccum, areaOther, readLatencyADC, readLatencyAccum, readLatencyOther, readDynamicEnergyADC, readDynamicEnergyAccum, readDynamicEnergyOther;
SwitchMatrix.cpp:		readLatency = 0;
SwitchMatrix.cpp:		readLatency += horowitz(tr, 0, rampInput, &rampOutput);	// get from chargeLatency in the original SubArray.cpp
SwitchMatrix.cpp:		readLatency *= numRead;
SwitchMatrix.cpp:		// readLatency += dff.readLatency;
SwitchMatrix.cpp:		writeLatency += dff.readLatency;	// Use DFF read latency here because no write in the DFF module
Tile.cpp:							double peSize, int speedUpRow, int speedUpCol, int weightMatrixRow, int weightMatrixCol, int numInVector, MemCell& cell, double *readLatency, double *readDynamicEnergy, double *leakage,
Tile.cpp:	double PEreadLatency, PEreadDynamicEnergy, PEleakage, PEbufferLatency, PEbufferDynamicEnergy, PEicLatency, PEicDynamicEnergy;
Tile.cpp:	*readLatency = 0;
Tile.cpp:											&PEreadLatency, &PEreadDynamicEnergy, &PEleakage,
Tile.cpp:				*readLatency = PEreadLatency/(numPE*numPE);  // further speed up in PE level
Tile.cpp:												&PEreadLatency, &PEreadDynamicEnergy, &PEleakage,
Tile.cpp:							*readLatency = MAX(PEreadLatency, (*readLatency));
Tile.cpp:				*readLatency /= (speedUpRow*speedUpCol);   // further speedup in PE level
Tile.cpp:					*readLatency += accumulationCM->readLatency; 
Tile.cpp:					*coreLatencyAccum += accumulationCM->readLatency; 
Tile.cpp:												numColMatrix, numInVector, cell, false, &PEreadLatency, &PEreadDynamicEnergy, &PEleakage,
Tile.cpp:					*readLatency = max(PEreadLatency, (*readLatency));
Tile.cpp:			*readLatency += accumulationCM->readLatency;
Tile.cpp:			*coreLatencyAccum += accumulationCM->readLatency;
Tile.cpp:					*readLatency += reLuCM->readLatency;
Tile.cpp:					*coreLatencyOther += reLuCM->readLatency;
Tile.cpp:					*readLatency += sigmoidCM->readLatency;
Tile.cpp:					*coreLatencyOther += sigmoidCM->readLatency;
Tile.cpp:			inputBufferCM->readLatency /= MIN(numInBufferCore, ceil(hTreeCM->busWidth/inputBufferCM->interface_width));
Tile.cpp:			outputBufferCM->readLatency /= MIN(numOutBufferCore, ceil(hTreeCM->busWidth/outputBufferCM->interface_width));
Tile.cpp:			*readLatency += (inputBufferCM->readLatency + inputBufferCM->writeLatency);
Tile.cpp:			*readLatency += (outputBufferCM->readLatency + outputBufferCM->writeLatency);
Tile.cpp:			*readLatency += hTreeCM->readLatency;
Tile.cpp:			*bufferLatency += (inputBufferCM->readLatency + outputBufferCM->readLatency + inputBufferCM->writeLatency + outputBufferCM->writeLatency);
Tile.cpp:			*icLatency += hTreeCM->readLatency;
Tile.cpp:			*coreLatencyOther += (inputBufferCM->readLatency + inputBufferCM->writeLatency + outputBufferCM->readLatency + outputBufferCM->writeLatency + hTreeCM->readLatency);
Tile.cpp:									weightMatrixCol, numInVector, cell, true, &PEreadLatency, &PEreadDynamicEnergy, &PEleakage,
Tile.cpp:			*readLatency = max(PEreadLatency, (*readLatency));
Tile.cpp:			*readLatency /= (speedUpRow*speedUpCol);
Tile.cpp:			*readLatency += accumulationNM->readLatency;
Tile.cpp:			*coreLatencyAccum += accumulationNM->readLatency;
Tile.cpp:					*readLatency += reLuNM->readLatency;
Tile.cpp:					*coreLatencyOther += reLuNM->readLatency;
Tile.cpp:					*readLatency += sigmoidNM->readLatency;
Tile.cpp:					*coreLatencyOther += sigmoidNM->readLatency;
Tile.cpp:			inputBufferNM->readLatency /= MIN(numInBufferCore, ceil(hTreeNM->busWidth/inputBufferNM->interface_width));
Tile.cpp:			outputBufferNM->readLatency /= MIN(numOutBufferCore, ceil(hTreeNM->busWidth/inputBufferNM->interface_width));
Tile.cpp:			*readLatency += inputBufferNM->readLatency + inputBufferNM->writeLatency;
Tile.cpp:			*readLatency += (outputBufferNM->readLatency + outputBufferNM->writeLatency);
Tile.cpp:			*readLatency += hTreeNM->readLatency;
Tile.cpp:			*bufferLatency += (inputBufferNM->readLatency + outputBufferNM->readLatency + inputBufferNM->writeLatency + outputBufferNM->writeLatency);
Tile.cpp:			*icLatency += hTreeNM->readLatency;
Tile.cpp:			*coreLatencyOther += (inputBufferNM->readLatency + inputBufferNM->writeLatency + outputBufferNM->readLatency + outputBufferNM->writeLatency + hTreeNM->readLatency);
Tile.h:			int speedUpRow, int speedUpCol, int weightMatrixRow, int weightMatrixCol, int numInVector, MemCell& cell, double *readLatency, double *readDynamicEnergy, double *leakage,
VoltageSenseAmp.cpp:		readLatency = 0;
VoltageSenseAmp.cpp:		readLatency += 2.3 * resPrecharge * capS1 + voltageSenseDiff * (capS1 + capNmosDrain + capInputLoad) / (cell.readVoltage/cell.resMemCellOn - cell.readVoltage/cell.resMemCellOff);
VoltageSenseAmp.cpp:		readLatency += 1/clkFreq * 2;	// Clock time for precharge and S/A enable
VoltageSenseAmp.cpp:		readLatency *= numRead;
WLDecoderOutput.cpp:		readLatency = 0;
WLDecoderOutput.cpp:		readLatency += horowitz(tr, beta, rampInput, NULL);
WLDecoderOutput.cpp:		readLatency += horowitz(tr, 0, 1e20, &rampOutput);	// get from chargeLatency in the original SubArray.cpp
WLDecoderOutput.cpp:		readLatency *= numRead;
WLDecoderOutput.cpp:		writeLatency = readLatency / numRead * numWrite;
WLNewDecoderDriver.cpp:		readLatency = writeLatency = 1e41;
WLNewDecoderDriver.cpp:		readLatency = 0;
WLNewDecoderDriver.cpp:		readLatency += horowitz(trnand, betanand, rampInput, NULL);
WLNewDecoderDriver.cpp:		readLatency += horowitz(trinv, betainv, rampInput, NULL);
WLNewDecoderDriver.cpp:		readLatency += horowitz(trnand, betanand, rampInput, NULL);
WLNewDecoderDriver.cpp:		readLatency += horowitz(trtg, 0, 1e20, &rampOutput);	// get from chargeLatency in the original SubArray.cpp
WLNewDecoderDriver.cpp:		readLatency *= numRead;
